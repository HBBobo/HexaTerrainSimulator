--- File Structure ---
index.html
src/
  App.css
  App.jsx
  index.css
  main.jsx
  assets/
    react.svg
  components/
    HexMap/
      constants.js
      HexMap.jsx
      buildings/
        BuildingTypes.js
        useBuildings.js
        models/
          createCampfireModel.js
          createFarmModel.js
          createHarbourModel.js
          createHouseModel.js
          createMineModel.js
          index.js
        utils/
          materialManager.js
      hooks/
        useFoxes.js
        useSunAndSky.js
        useThreeCore.js
        useThreeScene.js
        useWater.js
        useWeatherEffects.js
        useWorldGeometry.js
      ui/
        BuildingPalette.jsx
        SunControls.jsx
      utils/
        buildingUtils.js
        colorUtils.js
        foxUtils.js
        mapGenerator.js
        reedsUtils.js
        rockUtils.js
        threeUtils.js
        treeUtils.js

--- File Contents ---

## index.html ##
<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + React</title>
</head>
<body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
</body>
</html>

## src\App.css ##
body {
    margin: 0;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    background-color: #282c34;
    overflow: hidden;
}

.App {
    text-align: center;
}


## src\App.jsx ##
// src/App.jsx
import React from 'react';
import HexMap from './components/HexMap/HexMap';
import './App.css';

function App() {
    return (
        <div className="App">
            <HexMap />
        </div>
    );
}

export default App;

## src\index.css ##
body {
    margin: 0;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    background-color: #1e1e1e;
    color: white;
    overflow: hidden;
}

#root {
    width: 100vw;
    height: 100vh;
}


## src\main.jsx ##
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import './index.css';

const rootElement = document.getElementById('root');
const root = ReactDOM.createRoot(rootElement);

root.render(
    <React.StrictMode>
        <App />
    </React.StrictMode>
);

## src\assets\react.svg ##
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>

## src\components\HexMap\constants.js ##
// src/components/HexMap/constants.js
import { BUILDING_TYPES as BT } from './buildings/BuildingTypes'; // Import with an alias if needed

// --- Grid & Hex Dimensions ---
export const HEX_SIZE = 1;
export const HEX_HEIGHT_MAX = 8.0;
export const GRID_COLUMNS = 48;
export const GRID_ROWS = 48;

// --- Water Plane ---
export const TRANSPARENT_LAYER_Y = 0.505;
export const TRANSPARENT_LAYER_OPACITY = 0.6;
export const TRANSPARENT_LAYER_COLOR = 0x4682B4;

// --- Water Animation ---
export const MAX_WAVE_SPEED_COMPONENT = 0.03;
export const WAVE_DIRECTION_CHANGE_INTERVAL_MIN = 10.0;
export const WAVE_DIRECTION_CHANGE_INTERVAL_MAX = 20.0;
export const WAVE_SPEED_LERP_FACTOR = 0.02;

// --- Tile Types & Colors ---
export const TILE_TYPES = {
    DEEP_WATER: 'DEEP_WATER', SHALLOW_WATER: 'SHALLOW_WATER', SAND: 'SAND', CLAY: 'CLAY',
    PASTURE: 'PASTURE', FOREST: 'FOREST', STONE: 'STONE', MOUNTAIN_PEAK: 'MOUNTAIN_PEAK',
};
export const DULL_TILE_COLORS = {
    [TILE_TYPES.SAND]: 0xBDB76B, [TILE_TYPES.CLAY]: 0xCD853F, [TILE_TYPES.PASTURE]: 0x8FBC8F,
    [TILE_TYPES.FOREST]: 0x808060, [TILE_TYPES.STONE]: 0x778899, [TILE_TYPES.MOUNTAIN_PEAK]: 0xA9A9A9,
};
export const TILE_COLORS = DULL_TILE_COLORS;

// --- Building Types ---
// Now imported, but keep BUILDABLE_TILE_TYPES here or move it with BUILDING_TYPES
export const BUILDING_TYPES = BT; // Re-export if other files import from constants
export const BUILDABLE_TILE_TYPES = [
    TILE_TYPES.SAND, TILE_TYPES.CLAY, TILE_TYPES.PASTURE, TILE_TYPES.FOREST, TILE_TYPES.STONE
];


// --- Map Generation & Biome Thresholds ---
export const WATER_SURFACE_ELEVATION_NORMALIZED = TRANSPARENT_LAYER_Y / HEX_HEIGHT_MAX;
export const SHALLOW_WATER_DEPTH_FOR_REEDS_NORMALIZED = 0.06;
export const BIOME_THRESHOLDS = {
    [TILE_TYPES.SAND]: WATER_SURFACE_ELEVATION_NORMALIZED + 0.05,
    [TILE_TYPES.CLAY]: WATER_SURFACE_ELEVATION_NORMALIZED + 0.12,
    [TILE_TYPES.PASTURE]: WATER_SURFACE_ELEVATION_NORMALIZED + 0.30,
    [TILE_TYPES.FOREST]: WATER_SURFACE_ELEVATION_NORMALIZED + 0.50,
    [TILE_TYPES.STONE]: WATER_SURFACE_ELEVATION_NORMALIZED + 0.70,
};
export const MAP_GENERATOR_DEFAULTS = {
    NUM_ISLANDS: 4, ISLAND_SIZE_FACTOR: 0.35, NOISE_STRENGTH: 0.5,
    WARP_FACTOR: 0.2, ISLAND_BORDER_FACTOR: 0.8, RANDOMNESS_FACTOR: 0.08,
};

// --- Tree, Rock, Reed Placement ---
export const MIN_TREES_PER_FOREST_TILE = 2;
export const MAX_ADDITIONAL_TREES_PER_FOREST_TILE = 5;
export const PROBABILITY_OF_ADDITIONAL_TREE = 0.6;
export const ROCKS_PER_STONE_TILE_MIN = 1;
export const ROCKS_PER_STONE_TILE_MAX = 4;
export const PROBABILITY_OF_ROCK_ON_STONE_TILE = 0.7;
export const REED_CLUMPS_PER_ELIGIBLE_TILE_MIN = 7;
export const REED_CLUMPS_PER_ELIGIBLE_TILE_MAX = 13;
export const PROBABILITY_OF_REEDS_ON_ELIGIBLE_TILE = 0.55;

// --- Fox Settings ---
export const NUMBER_OF_FOXES = 5;
export const FOX_MAX_JUMP_HEIGHT_DIFFERENCE = HEX_SIZE * 0.75;

// --- Fox Footprints ---
export const FOX_FOOTPRINT_TEXTURE_URL = 'https://cdn0.iconfinder.com/data/icons/footprints-3/64/FOX-fox_terrier-wildlife-animals-carnivore-512.png';
export const FOX_FOOTPRINT_SIZE = 0.1;
export const FOX_FOOTPRINT_LIFETIME_SECONDS = 15.0;
export const FOX_FOOTPRINT_INTERVAL_SECONDS = 0.35;
export const FOX_FOOTPRINT_OPACITY = 0.6;
export const FOX_FOOTPRINT_Y_OFFSET = 0.015;
export const MIN_SNOW_FOR_FOOTPRINTS = 0.3;

// --- Sun, Moon & Lighting ---
export const SHADOW_MAP_SIZE = 4096;

// --- Time and Season ---
export const SEASONS = { SPRING: 0, SUMMER: 1, AUTUMN: 2, WINTER: 3 };
export const INITIAL_TIME_OF_DAY = 12;
export const INITIAL_SEASON = SEASONS.SUMMER;
export const MAX_SUN_ELEVATION_SUMMER = 75;
export const MAX_SUN_ELEVATION_WINTER = 30;
export const SUN_AZIMUTH_SWING = 90;

// --- Moon settings ---
export const MOON_LIGHT_INTENSITY = 0.4;
export const MOON_COLOR = 0xE0E8FF;
export const MOON_SIZE_FACTOR = 0.025;

// --- Weather ---
export const WEATHER_TYPES = {
    CLEAR: 'CLEAR',
    CLOUDY: 'CLOUDY',
    RAINY: 'RAINY',
    SNOW: 'SNOW',
};
export const INITIAL_WEATHER = WEATHER_TYPES.CLEAR;
export const SUN_INTENSITY_CLOUDY_FACTOR = 0.3;
export const MOON_INTENSITY_CLOUDY_FACTOR = 0.2;

// Rain Settings
export const RAIN_PARTICLE_COUNT = 100000;
export const RAIN_AREA_XZ_FACTOR = 1.5;
export const RAIN_AREA_Y_MAX = 50;
export const RAIN_FALL_SPEED = 30;
export const RAIN_PARTICLE_SIZE = 0.05;
export const RAIN_PARTICLE_OPACITY = 0.4;
export const RAIN_COLOR = 0xAAAAFF;

// Snow Settings
export const SNOW_PARTICLE_COUNT = 50000;
export const SNOW_AREA_XZ_FACTOR = 1.7;
export const SNOW_AREA_Y_MAX = 40;
export const SNOW_FALL_SPEED = 2.5;
export const SNOW_PARTICLE_SIZE = 0.15;
export const SNOW_PARTICLE_OPACITY = 0.7;
export const SNOW_PARTICLE_TEXTURE_URL = 'https://threejs.org/examples/textures/sprites/snowflake2.png';
export const SNOW_DRIFT_SPEED_X_FACTOR = 0.1;
export const SNOW_DRIFT_SPEED_Z_FACTOR = 0.05;

// Snow Cover on Ground/Assets
export const SNOW_COVER_COLOR = 0xE0E5E8;
export const MAX_SNOW_COVER_LERP_FACTOR = 0.85;
export const SNOW_ACCUMULATION_SECONDS = 10.0;
export const SNOW_MELT_SECONDS = 15.0;

// --- Skybox & Textures ---
export const SKYBOX_IMAGE_BASE_PATH = 'https://threejs.org/examples/textures/cube/SwedishRoyalCastle/';
export const SKYBOX_IMAGE_NAMES = ['px.jpg', 'nx.jpg', 'py.jpg', 'ny.jpg', 'pz.jpg', 'nz.jpg'];
export const WATER_NORMAL_MAP_URL = 'https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/waternormals.jpg';

## src\components\HexMap\HexMap.jsx ##
// src/components/HexMap/HexMap.jsx
import React, { useRef, useState, useMemo } from 'react';
import useThreeScene from './hooks/useThreeScene';
import SunControls from './ui/SunControls';
import BuildingPalette from './ui/BuildingPalette';
import { generateCoolIslandMap } from './utils/mapGenerator';
import { getSunLightColor, getMoonLightColor, calculateSunPosition } from './utils/colorUtils';
import {
    GRID_COLUMNS, GRID_ROWS, MAP_GENERATOR_DEFAULTS,
    INITIAL_TIME_OF_DAY, INITIAL_SEASON, INITIAL_WEATHER,
    MAX_SUN_ELEVATION_SUMMER, MAX_SUN_ELEVATION_WINTER, SUN_AZIMUTH_SWING,
} from './constants';
import { BUILDING_TYPES } from './buildings/BuildingTypes'; // For BuildingPalette available types

const HexMap = () => {
    const mountRef = useRef(null);
    const [timeOfDay, setTimeOfDay] = useState(INITIAL_TIME_OF_DAY);
    const [season, setSeason] = useState(INITIAL_SEASON);
    const [weather, setWeather] = useState(INITIAL_WEATHER);

    const islandHeightData = useMemo(() => {
        return generateCoolIslandMap(
            GRID_COLUMNS, GRID_ROWS,
            MAP_GENERATOR_DEFAULTS.NUM_ISLANDS, MAP_GENERATOR_DEFAULTS.ISLAND_SIZE_FACTOR,
            MAP_GENERATOR_DEFAULTS.NOISE_STRENGTH, MAP_GENERATOR_DEFAULTS.WARP_FACTOR,
            MAP_GENERATOR_DEFAULTS.ISLAND_BORDER_FACTOR, MAP_GENERATOR_DEFAULTS.RANDOMNESS_FACTOR
        );
    }, []);

    const buildingInteraction = useThreeScene(
        mountRef,
        islandHeightData,
        GRID_COLUMNS,
        GRID_ROWS,
        timeOfDay,
        season,
        weather
    );

    const { elevation: currentSunElevation } = calculateSunPosition(
        timeOfDay, season, MAX_SUN_ELEVATION_SUMMER, MAX_SUN_ELEVATION_WINTER, SUN_AZIMUTH_SWING
    );
    const moonTime = (timeOfDay + 12) % 24;
    const { elevation: currentMoonElevation } = calculateSunPosition(
        moonTime, season, 70, 70, 90
    );

    const currentSunLightUIColor = getSunLightColor(currentSunElevation);
    const currentMoonLightUIColor = currentMoonElevation > -5 ? getMoonLightColor(currentMoonElevation) : null;

    return (
        <div style={{ position: 'relative', width: '100vw', height: '100vh' }}>
            <div ref={mountRef} style={{ width: '100%', height: '100%', outline: 'none' }} tabIndex={-1} />
            <SunControls
                timeOfDay={timeOfDay} setTimeOfDay={setTimeOfDay}
                season={season} setSeason={setSeason}
                weather={weather} setWeather={setWeather}
                currentSunColor={currentSunLightUIColor}
                currentMoonColor={currentMoonLightUIColor}
            />
            {buildingInteraction && buildingInteraction.isBuildingPaletteOpen && (
                <BuildingPalette
                    selectedTile={buildingInteraction.selectedTileForBuilding}
                    onBuild={buildingInteraction.onBuild}
                    onCancel={buildingInteraction.onCancel}
                    existingBuildingType={buildingInteraction.existingBuildingOnSelectedTile?.type}
                    existingBuildingRotation={buildingInteraction.existingBuildingOnSelectedTile?.rotationY}
                    onUpdateBuilding={buildingInteraction.onUpdateBuilding} // Pass the new handler
                    availableBuildingTypes={Object.values(BUILDING_TYPES)} // Pass all building types
                />
            )}
        </div>
    );
};

export default HexMap;

## src\components\HexMap\buildings\BuildingTypes.js ##
// src/components/HexMap/buildings/BuildingTypes.js

export const BUILDING_TYPES = {
    HOUSE: 'HOUSE',
    FARM: 'FARM',
    MINE: 'MINE',
    CAMPFIRE: 'CAMPFIRE',
    HARBOUR: 'HARBOUR',
    // Add more as needed
};

## src\components\HexMap\buildings\useBuildings.js ##
// src/components/HexMap/buildings/useBuildings.js
import { useEffect, useRef, useState, useCallback } from 'react';
import * as THREE from 'three';
import { BUILDING_TYPES } from './BuildingTypes';
import * as BuildingModels from './models';
import { updateBuildingInstanceSnow, disposeAllCachedMaterials } from './utils/materialManager';

const getTileKey = (c, r) => `${c},${r}`;

const useBuildings = (coreElements, snowAccumulationRatio, timeOfDay, landTileMap, gridColumns, gridRows) => {
    const [buildingsSystemData, setBuildingsSystemData] = useState(null);
    const placedBuildingsRef = useRef(new Map());
    const buildingsGroupRef = useRef(null);

    useEffect(() => {
        if (!coreElements || !coreElements.isReady || !coreElements.scene) {
            if (buildingsSystemData) {
                setBuildingsSystemData(null);
            }
            return;
        }

        const { scene } = coreElements;
        console.log("useBuildings: Initializing...");

        buildingsGroupRef.current = new THREE.Group();
        buildingsGroupRef.current.name = "BuildingsGroup";
        scene.add(buildingsGroupRef.current);

        setBuildingsSystemData({
            isReady: true,
        });

        return () => {
            console.log("useBuildings: Cleaning up...");
            if (buildingsGroupRef.current) {
                placedBuildingsRef.current.forEach(building => {
                    if (building.model) {
                        if (building.model.userData.light && building.model.userData.light.parent) {
                            building.model.userData.light.parent.remove(building.model.userData.light);
                        }
                        if (building.model.userData.pierLampLight && building.model.userData.pierLampLight.parent) { // Cleanup for harbour lamp
                            building.model.userData.pierLampLight.parent.remove(building.model.userData.pierLampLight);
                        }
                        buildingsGroupRef.current.remove(building.model);
                        building.model.traverse(node => {
                            if (node.isMesh) {
                                if (node.geometry) node.geometry.dispose();
                            }
                        });
                    }
                });
                if (scene && buildingsGroupRef.current.parent === scene) {
                    scene.remove(buildingsGroupRef.current);
                }
                buildingsGroupRef.current = null;
            }
            placedBuildingsRef.current.clear();
            disposeAllCachedMaterials();
            setBuildingsSystemData(null);
        };
    }, [coreElements]);


    const addBuilding = useCallback((tileData, buildingType) => {
        if (!buildingsSystemData || !buildingsSystemData.isReady || !buildingsGroupRef.current || !tileData) {
            console.error("Building system not ready or no tile data provided.");
            return;
        }

        const tileKey = getTileKey(tileData.c, tileData.r);

        if (placedBuildingsRef.current.has(tileKey)) {
            const existing = placedBuildingsRef.current.get(tileKey);
            if (existing.model) {
                if (existing.model.userData.light && existing.model.userData.light.parent) {
                    existing.model.userData.light.parent.remove(existing.model.userData.light);
                }
                if (existing.model.userData.pierLampLight && existing.model.userData.pierLampLight.parent) {
                    existing.model.userData.pierLampLight.parent.remove(existing.model.userData.pierLampLight);
                }
                buildingsGroupRef.current.remove(existing.model);
                existing.model.traverse(node => {
                    if (node.isMesh && node.geometry) node.geometry.dispose();
                });
            }
        }

        let buildingModel;
        const modelArgs = [tileData.y, tileData, landTileMap, gridColumns, gridRows];

        switch (buildingType) {
            case BUILDING_TYPES.HOUSE:
                buildingModel = BuildingModels.createHouseModel(...modelArgs.slice(0, 1));
                break;
            case BUILDING_TYPES.CAMPFIRE:
                buildingModel = BuildingModels.createCampfireModel(...modelArgs.slice(0, 1));
                break;
            case BUILDING_TYPES.FARM:
                buildingModel = BuildingModels.createFarmModel(...modelArgs.slice(0, 1));
                break;
            case BUILDING_TYPES.MINE:
                buildingModel = BuildingModels.createMineModel(...modelArgs.slice(0, 1));
                break;
            case BUILDING_TYPES.HARBOUR:
                buildingModel = BuildingModels.createHarbourModel(...modelArgs);
                break;
            default:
                console.warn(`Building type ${buildingType} model creator not found. Using placeholder.`);
                const placeholderGeo = new THREE.BoxGeometry(0.4, 0.4, 0.4);
                const placeholderMat = new THREE.MeshStandardMaterial({ color: 0x8888FF });
                placeholderMat.userData = { isRoof: true };
                const placeholder = new THREE.Mesh(placeholderGeo, placeholderMat);
                placeholder.position.y = tileData.y + 0.2;
                placeholder.castShadow = true;
                buildingModel = new THREE.Group();
                buildingModel.add(placeholder);
                buildingModel.userData.isBuilding = true;
                buildingModel.userData.buildingType = 'PLACEHOLDER';
                buildingModel.userData.animate = (time) => { };
        }

        if (!buildingModel) {
            console.error("Failed to create building model for type:", buildingType);
            return;
        }

        let initialRotationY = buildingModel.rotation.y; // Use model's default if set
        // For non-Harbour buildings, if rotation is not already set by the model creation function, randomize it.
        if (buildingType !== BUILDING_TYPES.HARBOUR && buildingModel.rotation.y === 0) {
            initialRotationY = Math.random() * Math.PI * 2;
            buildingModel.rotation.y = initialRotationY;
        } else if (buildingType === BUILDING_TYPES.HARBOUR) {
            // Harbours manage their pier rotation internally. The main group's rotation is effectively 0.
            initialRotationY = buildingModel.rotation.y; // Should be 0 for the main group
        }

        buildingModel.position.set(tileData.x, 0, tileData.z);
        updateBuildingInstanceSnow(buildingModel, snowAccumulationRatio);
        buildingsGroupRef.current.add(buildingModel);
        placedBuildingsRef.current.set(tileKey, { type: buildingType, model: buildingModel, tileData, rotationY: initialRotationY });

    }, [buildingsSystemData, snowAccumulationRatio, landTileMap, gridColumns, gridRows]);


    const updateBuilding = useCallback((tileData, updates) => {
        if (!buildingsSystemData || !buildingsSystemData.isReady || !tileData) {
            console.error("Building system not ready or no tile data for updateBuilding.");
            return;
        }
        const tileKey = getTileKey(tileData.c, tileData.r);
        const buildingData = placedBuildingsRef.current.get(tileKey);

        if (buildingData && buildingData.model) {
            if (updates.rotationY !== undefined) {
                if (buildingData.type !== BUILDING_TYPES.HARBOUR) {
                    buildingData.model.rotation.y = updates.rotationY;
                    placedBuildingsRef.current.set(tileKey, { ...buildingData, rotationY: updates.rotationY });
                } else {
                    console.warn("Harbour rotation is determined by pier placement and cannot be manually changed this way.");
                }
            }
            // Future: handle other updates like toggling lights, etc.
            // if (updates.toggleLight !== undefined && buildingData.model.userData.animate) {
            //    // This would require more complex logic in animate functions or dedicated toggle functions
            // }
            updateBuildingInstanceSnow(buildingData.model, snowAccumulationRatio); // Re-apply snow in case color was affected
        }
    }, [buildingsSystemData, snowAccumulationRatio]);


    const updateAllBuildingsSnow = useCallback(() => {
        if (!buildingsSystemData || !buildingsSystemData.isReady || snowAccumulationRatio === undefined) return;
        placedBuildingsRef.current.forEach(building => {
            if (building.model) {
                updateBuildingInstanceSnow(building.model, snowAccumulationRatio);
            }
        });
    }, [buildingsSystemData, snowAccumulationRatio]);

    useEffect(() => {
        updateAllBuildingsSnow();
    }, [snowAccumulationRatio, updateAllBuildingsSnow]);


    const getBuildingOnTile = useCallback((c, r) => {
        const tileKey = getTileKey(c, r);
        const buildingData = placedBuildingsRef.current.get(tileKey);
        if (buildingData && buildingData.model) {
            let isLit = false;
            // Consolidate light checking
            const lightSources = [
                buildingData.model.userData.light,
                buildingData.model.userData.doorLampLight,
                buildingData.model.userData.mineLampLight,
                buildingData.model.userData.pierLampLight
            ];
            for (const light of lightSources) {
                if (light && light.intensity > 0.05) {
                    isLit = true;
                    break;
                }
            }
            if (typeof buildingData.model.userData.isLit === 'function') { // For specific isLit functions like campfire
                isLit = isLit || buildingData.model.userData.isLit();
            }


            return {
                type: buildingData.type,
                model: buildingData.model, // Be cautious about exposing the whole model
                isLit: isLit,
                rotationY: buildingData.rotationY, // Include current rotation
            };
        }
        return undefined;
    }, []);


    const updateBuildingAnimations = useCallback((elapsedTime) => {
        if (!buildingsSystemData || !buildingsSystemData.isReady) return;
        placedBuildingsRef.current.forEach(building => {
            if (building.model && building.model.userData && typeof building.model.userData.animate === 'function') {
                building.model.userData.animate(elapsedTime, timeOfDay);
            }
        });
    }, [buildingsSystemData, timeOfDay]);


    if (buildingsSystemData && buildingsSystemData.isReady) {
        return {
            ...buildingsSystemData,
            addBuilding,
            getBuildingOnTile,
            updateBuildingAnimations,
            updateBuilding, // Expose the new update function
        };
    }
    return null;
};

export default useBuildings;

## src\components\HexMap\buildings\models\createCampfireModel.js ##
// src/components/HexMap/buildings/models/createCampfireModel.js
import * as THREE from 'three';
import { BUILDING_TYPES } from '../BuildingTypes' // Adjust path
import { getCachedMaterial } from '../utils/materialManager'; // Adjust path

const CAMPFIRE_WOOD_COLOR = 0x8B4513;
const CAMPFIRE_STONE_COLOR = 0x808080;
const FLAME_COLOR_YELLOW = 0xFFFFAA;
const FLAME_COLOR_ORANGE = 0xFFAA33;

export const createCampfireModel = (tileY) => {
    const campfireGroup = new THREE.Group();
    campfireGroup.userData.isBuilding = true;
    campfireGroup.userData.buildingType = BUILDING_TYPES.CAMPFIRE;

    const stoneMaterial = getCachedMaterial(CAMPFIRE_STONE_COLOR, { roughness: 0.8, metalness: 0.2 });
    stoneMaterial.userData = { isRoof: true };
    const woodMaterial = getCachedMaterial(CAMPFIRE_WOOD_COLOR, { roughness: 0.9, metalness: 0.05 });
    woodMaterial.userData = { isRoof: true };

    const baseRadius = 0.18;
    const stoneHeight = 0.06;
    const groundY = tileY + stoneHeight / 2;

    for (let i = 0; i < 8; i++) {
        const angle = (i / 8) * Math.PI * 2;
        const stoneGeo = new THREE.BoxGeometry(0.07, stoneHeight, 0.07);
        const stone = new THREE.Mesh(stoneGeo, stoneMaterial);
        stone.position.set(
            Math.cos(angle) * (baseRadius - 0.035),
            groundY,
            Math.sin(angle) * (baseRadius - 0.035)
        );
        stone.castShadow = true;
        campfireGroup.add(stone);
    }

    const logLength = 0.22;
    const logRadius = 0.025;
    const logGeo = new THREE.CylinderGeometry(logRadius, logRadius, logLength, 5);

    const logPositions = [
        { yOff: logRadius, rotZ: Math.PI / 2, rotY: 0, zOff: -logRadius * 1.2 },
        { yOff: logRadius, rotZ: Math.PI / 2, rotY: Math.PI / 2.5, zOff: 0, xOff: logRadius * 0.8 },
        { yOff: logRadius, rotZ: Math.PI / 2, rotY: -Math.PI / 2.5, zOff: 0, xOff: -logRadius * 0.8 },
        { yOff: logRadius * 3, rotZ: Math.PI / 2, rotY: Math.PI / 6, zOff: -logRadius * 0.5 },
    ];

    logPositions.forEach(p => {
        const log = new THREE.Mesh(logGeo, woodMaterial);
        log.rotation.z = p.rotZ;
        if (p.rotY) log.rotation.y = p.rotY;
        log.position.set(p.xOff || 0, groundY - stoneHeight / 2 + p.yOff, p.zOff || 0);
        log.castShadow = true;
        campfireGroup.add(log);
    });

    const numSittingStones = 3 + Math.floor(Math.random() * 3);
    const sittingStoneMinRadius = baseRadius + 0.12;
    const sittingStoneMaxRadius = baseRadius + 0.22;
    let lastAngle = Math.random() * Math.PI * 2;

    for (let i = 0; i < numSittingStones; i++) {
        const angleOffset = (Math.PI * 2 / numSittingStones) * (0.8 + Math.random() * 0.4);
        const angle = lastAngle + angleOffset;
        lastAngle = angle;
        const currentRadius = sittingStoneMinRadius + Math.random() * (sittingStoneMaxRadius - sittingStoneMinRadius);
        const sitStoneSize = 0.08 + Math.random() * 0.07;
        const sitStoneGeo = new THREE.DodecahedronGeometry(sitStoneSize / 1.5, 0);
        const sitStone = new THREE.Mesh(sitStoneGeo, stoneMaterial);
        sitStone.position.set(
            Math.cos(angle) * currentRadius,
            tileY + sitStoneSize / 2,
            Math.sin(angle) * currentRadius
        );
        sitStone.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
        sitStone.castShadow = true;
        sitStone.receiveShadow = true;
        campfireGroup.add(sitStone);
    }

    const flameGroup = new THREE.Group();
    flameGroup.position.y = groundY + logRadius * 2.5;
    campfireGroup.add(flameGroup);

    const flameMaterialOuter = getCachedMaterial(FLAME_COLOR_ORANGE, { transparent: true, opacity: 0.6, side: THREE.DoubleSide, emissive: FLAME_COLOR_ORANGE, emissiveIntensity: 0.5, depthWrite: false }, true);
    const flameMaterialInner = getCachedMaterial(FLAME_COLOR_YELLOW, { transparent: true, opacity: 0.8, side: THREE.DoubleSide, emissive: FLAME_COLOR_YELLOW, emissiveIntensity: 0.8, depthWrite: false }, true);

    const createFlamePlane = (material, size, yOffset) => {
        const planeGeo = new THREE.PlaneGeometry(size, size * 1.8);
        const plane = new THREE.Mesh(planeGeo, material);
        plane.position.y = yOffset + (size * 1.8) / 2;
        return plane;
    };

    const flame1Outer = createFlamePlane(flameMaterialOuter, 0.08, 0);
    const flame1Inner = createFlamePlane(flameMaterialInner, 0.05, 0.01);
    flame1Outer.add(flame1Inner);
    flameGroup.add(flame1Outer);

    const flame2Outer = createFlamePlane(flameMaterialOuter, 0.07, 0.02);
    flame2Outer.rotation.y = Math.PI / 2;
    const flame2Inner = createFlamePlane(flameMaterialInner, 0.04, 0.03);
    flame2Outer.add(flame2Inner);
    flameGroup.add(flame2Outer);

    campfireGroup.userData.flames = [flame1Outer, flame2Outer];

    const fireLight = new THREE.PointLight(FLAME_COLOR_ORANGE, 1.5, 3.5, 1.8);
    fireLight.position.copy(flameGroup.position);
    fireLight.position.y += 0.1;
    fireLight.castShadow = true;
    fireLight.shadow.mapSize.width = 256;
    fireLight.shadow.mapSize.height = 256;
    fireLight.shadow.camera.near = 0.1;
    fireLight.shadow.camera.far = 3;
    campfireGroup.add(fireLight);
    campfireGroup.userData.light = fireLight;
    campfireGroup.userData.isLit = () => fireLight.intensity > 0.3 && fireLight.visible;

    campfireGroup.userData.animate = (time, timeOfDay) => {
        const flames = campfireGroup.userData.flames;
        if (flames) {
            flames.forEach((flame, index) => {
                const scaleFactor = 0.9 + Math.sin(time * (5 + index) + index * 0.5) * 0.15;
                flame.scale.set(scaleFactor, scaleFactor, scaleFactor);
                flame.material.opacity = 0.5 + Math.sin(time * (6 + index) + index * 0.7) * 0.2;
                if (flame.children.length > 0 && flame.children[0].material) {
                    flame.children[0].material.opacity = 0.7 + Math.sin(time * (7 + index) + index * 0.9) * 0.25;
                }
            });
        }
        const light = campfireGroup.userData.light;
        if (light) {
            if (timeOfDay > 18 || timeOfDay < 6) {
                light.intensity = THREE.MathUtils.lerp(light.intensity, 2.0 + Math.sin(time * 3) * 0.3, 0.1);
            } else if (timeOfDay > 6 && timeOfDay < 8) {
                light.intensity = THREE.MathUtils.lerp(light.intensity, 1.0 + Math.sin(time * 3) * 0.2, 0.1);
            }
            else {
                light.intensity = THREE.MathUtils.lerp(light.intensity, 0.5 + Math.sin(time * 3) * 0.1, 0.1);
            }
            light.visible = light.intensity > 0.1;
        }
    };

    return campfireGroup;
};

## src\components\HexMap\buildings\models\createFarmModel.js ##
// src/components/HexMap/buildings/models/createFarmModel.js
import * as THREE from 'three';
import { BUILDING_TYPES } from '../BuildingTypes' // Adjust path
import { getCachedMaterial } from '../utils/materialManager'; // Adjust path

const FARM_SOIL_COLOR = 0x654321;
const FARM_FENCE_COLOR = 0x8B7355;

export const createFarmModel = (tileY) => {
    const farmGroup = new THREE.Group();
    farmGroup.userData.isBuilding = true;
    farmGroup.userData.buildingType = BUILDING_TYPES.FARM;
    farmGroup.userData.animate = (time) => { };

    const soilSize = 0.65;
    const soilHeight = 0.04;
    const soilMaterial = getCachedMaterial(FARM_SOIL_COLOR, { roughness: 0.9 });
    soilMaterial.userData = { isRoof: true };
    const soilGeo = new THREE.BoxGeometry(soilSize, soilHeight, soilSize);
    const soilMesh = new THREE.Mesh(soilGeo, soilMaterial);
    soilMesh.position.y = tileY + soilHeight / 2;
    soilMesh.castShadow = false;
    soilMesh.receiveShadow = true;
    farmGroup.add(soilMesh);

    const fencePostHeight = 0.12;
    const fencePostRadius = 0.012;
    const fenceMaterial = getCachedMaterial(FARM_FENCE_COLOR, { roughness: 0.85 });
    fenceMaterial.userData = { isRoof: true };
    const postGeo = new THREE.CylinderGeometry(fencePostRadius, fencePostRadius, fencePostHeight, 4);

    const s = soilSize / 2;
    const fenceCoords = [
        [-s, -s], [0, -s], [s, -s], [-s, 0], [s, 0], [-s, s], [0, s], [s, s]
    ];

    fenceCoords.forEach(coord => {
        const post = new THREE.Mesh(postGeo, fenceMaterial);
        post.position.set(coord[0], tileY + soilHeight + fencePostHeight / 2 - soilHeight / 2, coord[1]);
        post.castShadow = true;
        farmGroup.add(post);
    });

    return farmGroup;
};

## src\components\HexMap\buildings\models\createHarbourModel.js ##
// src/components/HexMap/buildings/models/createHarbourModel.js
import * as THREE from 'three';
import { BUILDING_TYPES as BT, TRANSPARENT_LAYER_Y, HEX_SIZE, TILE_TYPES } from '../../constants';
import { getCachedMaterial } from '../utils/materialManager';

const PIER_WOOD_COLOR = 0x8B7355;
const BOAT_WOOD_COLOR = 0xA0522D;
const BOAT_TRIM_COLOR = 0xD2B48C;
// const PADDLE_WOOD_COLOR = 0x966F33; // Unused currently

const WATER_SURFACE_Y = TRANSPARENT_LAYER_Y;

// --- Pier Lamp Constants ---
const PIER_LAMP_POST_COLOR = 0x554433; // Weathered wood/metal, slightly darker than pier
const PIER_LAMP_SHADE_COLOR = 0xD2B48C; // Similar to boat trim, could be canvas/tarnished metal
const PIER_LAMP_EMISSIVE_COLOR = 0xFFD700; // Golden yellow, like an oil lamp

// Helper function to create the lamp model for the pier
const createPierLampModel = (baseY) => {
    const lampGroup = new THREE.Group();
    lampGroup.name = "PierLampAssembly";

    const lampPostMaterial = getCachedMaterial(PIER_LAMP_POST_COLOR, { roughness: 0.8 });
    const lampShadeMaterial = getCachedMaterial(PIER_LAMP_SHADE_COLOR, {
        roughness: 0.7,
        emissive: PIER_LAMP_EMISSIVE_COLOR,
        emissiveIntensity: 0.0 // Start off
    }, true); // Mark as special emissive for material manager
    // UserData for snow interaction and identifying parts
    lampShadeMaterial.userData = { isPierLampComponent: true, isLampShade: true };
    lampPostMaterial.userData = { isPierLampComponent: true };


    const postHeight = 0.7; // Pier lamp might be a bit taller
    const postRadius = 0.035;
    const lampPostGeo = new THREE.CylinderGeometry(postRadius, postRadius * 0.9, postHeight, 6);
    const lampPost = new THREE.Mesh(lampPostGeo, lampPostMaterial);
    lampPost.position.y = postHeight / 2; // Base of post is at baseY passed to lampGroup
    lampPost.castShadow = true;
    lampGroup.add(lampPost);

    const armLength = 0.20;
    const armThickness = 0.03;
    const lampArmGeo = new THREE.BoxGeometry(armThickness, armThickness, armLength);
    const lampArm = new THREE.Mesh(lampArmGeo, lampPostMaterial);
    // Position arm near top of post, extending out (local Z for arm)
    lampArm.position.set(0, postHeight - armThickness * 2.5, armLength / 2 - armThickness / 2);
    lampArm.castShadow = true;
    lampGroup.add(lampArm); // Add arm to the lampGroup, not post, for easier whole-lamp rotation if needed

    const shadeRadiusTop = 0.06;
    const shadeRadiusBottom = 0.09;
    const shadeHeight = 0.12;
    const lampShadeGeo = new THREE.CylinderGeometry(shadeRadiusTop, shadeRadiusBottom, shadeHeight, 8);
    const lampShade = new THREE.Mesh(lampShadeGeo, lampShadeMaterial);
    // Position shade hanging from the arm
    lampShade.position.set(0, -shadeHeight / 2 - armThickness, armLength - armThickness * 1.5); // Hang from end of arm
    lampShade.castShadow = true;
    lampArm.add(lampShade); // Add shade as child of arm

    const pierLampLight = new THREE.PointLight(PIER_LAMP_EMISSIVE_COLOR, 0, 1.8, 2.0); // intensity, distance, decay
    pierLampLight.castShadow = false; // Performance, can be true if desired
    // Position light inside/below the shade, relative to the shade's parent (lampArm)
    pierLampLight.position.copy(lampShade.position);
    pierLampLight.position.y -= shadeHeight * 0.3; // Slightly below center of shade
    lampArm.add(pierLampLight); // Add light as child of arm

    lampGroup.userData.light = pierLampLight;
    lampGroup.userData.shadeMaterial = lampShadeMaterial;

    // The lampGroup's base (y=0) will be placed on pierDeckY
    lampGroup.position.y = baseY;


    return lampGroup;
};


export const createHarbourModel = (tileY, tileData, landTileMap, gridColumns, gridRows) => {
    const harbourGroup = new THREE.Group();
    harbourGroup.userData.isBuilding = true;
    harbourGroup.userData.buildingType = BT.HARBOUR;

    const woodMaterial = getCachedMaterial(PIER_WOOD_COLOR, { roughness: 0.8 });
    woodMaterial.userData = { isRoof: true }; // Pier deck acts as a roof for snow
    const boatBodyMaterial = getCachedMaterial(BOAT_WOOD_COLOR, { roughness: 0.7 });
    // boatBodyMaterial.userData = { isRoof: true };
    const boatTrimMaterial = getCachedMaterial(BOAT_TRIM_COLOR, { roughness: 0.65 });
    boatTrimMaterial.userData = { isRoof: true };

    // --- Determine Pier Direction ---
    let pierDirectionVector = new THREE.Vector3(0, 0, 1); // Default if no water found
    let validWaterNeighborsDirections = [];
    const getAdjacentHexInfo = (c, r) => {
        const isOddRow = r % 2 === 1;
        return [
            { dc: 1, dr: 0 }, { dc: -1, dr: 0 },
            { dc: isOddRow ? 1 : 0, dr: 1 }, { dc: isOddRow ? 0 : -1, dr: 1 },
            { dc: isOddRow ? 1 : 0, dr: -1 }, { dc: isOddRow ? 0 : -1, dr: -1 }
        ].map(n => ({ nc: c + n.dc, nr: r + n.dr }));
    };
    const neighbors = getAdjacentHexInfo(tileData.c, tileData.r);
    for (const neighbor of neighbors) {
        if (neighbor.nc >= 0 && neighbor.nc < gridColumns && neighbor.nr >= 0 && neighbor.nr < gridRows) {
            const key = `${neighbor.nc},${neighbor.nr}`;
            const adjacentTile = landTileMap.get(key);
            if (adjacentTile && (adjacentTile.type === TILE_TYPES.DEEP_WATER || adjacentTile.type === TILE_TYPES.SHALLOW_WATER)) {
                const directionToWater = new THREE.Vector3(adjacentTile.x - tileData.x, 0, adjacentTile.z - tileData.z).normalize();
                validWaterNeighborsDirections.push(directionToWater);
            }
        }
    }
    if (validWaterNeighborsDirections.length > 0) {
        pierDirectionVector = validWaterNeighborsDirections[Math.floor(Math.random() * validWaterNeighborsDirections.length)];
    } else {
        console.warn(`Harbour at (${tileData.c},${tileData.r}) couldn't find adjacent water tile for pier direction. Using default Z+ locally.`);
    }

    const pierGroup = new THREE.Group();
    pierGroup.name = "PierStructure";
    const pierStartOffset = HEX_SIZE * 0.55;
    const pierLength = HEX_SIZE * 2.0;
    const pierWidth = HEX_SIZE * 0.5;
    const plankThickness = 0.04;
    const postRadius = 0.03;
    const pierDeckY = tileY + 0.05;

    const deckGeo = new THREE.BoxGeometry(pierWidth, plankThickness, pierLength);
    const deckMesh = new THREE.Mesh(deckGeo, woodMaterial);
    deckMesh.position.set(0, pierDeckY - plankThickness / 2, pierStartOffset + pierLength / 2);
    deckMesh.castShadow = true;
    deckMesh.receiveShadow = true;
    pierGroup.add(deckMesh);

    const numPostPairs = Math.max(3, Math.floor(pierLength / (HEX_SIZE * 0.55))) + 1;
    for (let i = 0; i < numPostPairs; i++) {
        const fractionAlongPier = (numPostPairs > 1) ? (i / (numPostPairs - 1)) : 0.5;
        const localZForPost = pierStartOffset + (fractionAlongPier * pierLength);
        const postBaseYForPier = 0.0;
        const actualPostHeight = (pierDeckY + plankThickness) - postBaseYForPier;
        const postGeo = new THREE.CylinderGeometry(postRadius, postRadius * 0.9, actualPostHeight, 6);
        [-pierWidth / 2 + postRadius * 1.2, pierWidth / 2 - postRadius * 1.2].forEach(xOffset => {
            const post = new THREE.Mesh(postGeo, woodMaterial);
            post.position.set(xOffset, postBaseYForPier + actualPostHeight / 2, localZForPost);
            post.castShadow = true;
            pierGroup.add(post);
        });
    }

    const pierLamp = createPierLampModel(pierDeckY);
    pierLamp.position.set(0, tileY, pierStartOffset + pierLength - HEX_SIZE * 0.15);
    pierLamp.rotation.y = Math.PI;
    pierGroup.add(pierLamp);

    harbourGroup.userData.pierLampLight = pierLamp.userData.light;
    harbourGroup.userData.pierLampShadeMaterial = pierLamp.userData.shadeMaterial;

    pierGroup.quaternion.setFromUnitVectors(new THREE.Vector3(0, 0, 1), pierDirectionVector);
    harbourGroup.add(pierGroup);

    const boatGroup = new THREE.Group();
    boatGroup.name = "PierBoat";
    const boatLength = HEX_SIZE * 0.85;
    const boatOuterWidth = HEX_SIZE * 0.40;
    const boatWallHeight = HEX_SIZE * 0.20;
    const boatFloorThickness = HEX_SIZE * 0.05;
    const wallThickness = HEX_SIZE * 0.03;
    const epsilon = wallThickness * 0.1;

    const floorWidth = (boatOuterWidth - 2 * wallThickness) + epsilon;
    const floorLength = boatLength;
    const floorGeo = new THREE.BoxGeometry(floorWidth, boatFloorThickness, floorLength);
    const floorMesh = new THREE.Mesh(floorGeo, boatBodyMaterial);
    boatGroup.add(floorMesh);

    const sideWallLength = boatLength + epsilon;
    const sideWallGeo = new THREE.BoxGeometry(wallThickness, boatWallHeight, sideWallLength);
    const wallPositionY = boatFloorThickness / 2 + boatWallHeight / 2;

    const portWall = new THREE.Mesh(sideWallGeo, boatBodyMaterial);
    portWall.position.set(-(boatOuterWidth / 2 - wallThickness / 2), wallPositionY, 0);
    boatGroup.add(portWall);

    const starboardWall = new THREE.Mesh(sideWallGeo, boatBodyMaterial);
    starboardWall.position.set(boatOuterWidth / 2 - wallThickness / 2, wallPositionY, 0);
    boatGroup.add(starboardWall);

    const endWallWidth = (boatOuterWidth - 2 * wallThickness) + epsilon;
    const endWallGeo = new THREE.BoxGeometry(endWallWidth, boatWallHeight, wallThickness);

    const sternWall = new THREE.Mesh(endWallGeo, boatBodyMaterial);
    sternWall.position.set(0, wallPositionY, -boatLength / 2 + wallThickness / 2);
    boatGroup.add(sternWall);

    const bowWall = new THREE.Mesh(endWallGeo, boatBodyMaterial);
    bowWall.position.set(0, wallPositionY, boatLength / 2 - wallThickness / 2);
    boatGroup.add(bowWall);

    const seatWidth = (boatOuterWidth - 2 * wallThickness) - epsilon;
    const seatDepth = wallThickness * 2.5;
    const seatHeight = wallThickness * 0.8;
    const seatGeo = new THREE.BoxGeometry(seatWidth, seatHeight, seatDepth);
    const seatBaseY = boatFloorThickness / 2 + seatHeight / 2;

    const seat1 = new THREE.Mesh(seatGeo, boatTrimMaterial);
    seat1.position.set(0, seatBaseY + boatWallHeight * 0.15, boatLength * 0.22);
    boatGroup.add(seat1);

    const seat2 = seat1.clone();
    seat2.position.set(0, seatBaseY + boatWallHeight * 0.15, -boatLength * 0.22);
    boatGroup.add(seat2);

    const boatPlacementT = 0.65 + Math.random() * 0.3;
    const pierPointForBoat = pierDirectionVector.clone().multiplyScalar(pierStartOffset + pierLength * boatPlacementT);
    const sideOffsetDirection = new THREE.Vector3().crossVectors(pierDirectionVector, new THREE.Vector3(0, 1, 0)).normalize();
    const boatSideOffsetMagnitude = (pierWidth / 2 + boatOuterWidth / 2 + HEX_SIZE * 0.15);
    const boatSideOffsetFinal = boatSideOffsetMagnitude * (Math.random() < 0.5 ? 1 : -1);

    boatGroup.position.copy(pierPointForBoat);
    boatGroup.position.addScaledVector(sideOffsetDirection, boatSideOffsetFinal);
    boatGroup.position.y = WATER_SURFACE_Y - boatFloorThickness * 0.7;
    boatGroup.quaternion.setFromUnitVectors(new THREE.Vector3(0, 0, 1), pierDirectionVector);
    boatGroup.rotation.y += (Math.random() - 0.5) * 0.4;
    harbourGroup.add(boatGroup);
    harbourGroup.userData.boat = boatGroup;

    harbourGroup.userData.animate = (time, timeOfDay) => {
        const boat = harbourGroup.userData.boat;
        if (boat) {
            const baseBobY = WATER_SURFACE_Y - boatFloorThickness * 0.7;
            boat.position.y = baseBobY + Math.sin(time * 0.75 + tileData.x + tileData.z) * 0.03;
            boat.rotation.x = Math.sin(time * 0.55 + tileData.z) * 0.035;
            boat.rotation.z = Math.cos(time * 0.65 + tileData.x * 0.5) * 0.03;
        }

        const pierLight = harbourGroup.userData.pierLampLight;
        const pierShadeMat = harbourGroup.userData.pierLampShadeMaterial;

        if (pierLight && pierShadeMat) {
            let targetLampIntensity = 0.0;
            let targetLampEmissive = 0.0;
            const eveningStart = 18.0;
            const nightStart = 19.5;
            const morningEnd = 6.5;
            const peakLampLightIntensity = 0.7;
            const peakLampEmissiveIntensity = 0.6;

            if (timeOfDay >= eveningStart && timeOfDay < nightStart) {
                const factor = (timeOfDay - eveningStart) / (nightStart - eveningStart);
                targetLampIntensity = THREE.MathUtils.lerp(0, peakLampLightIntensity, factor);
                targetLampEmissive = THREE.MathUtils.lerp(0, peakLampEmissiveIntensity, factor);
            } else if (timeOfDay >= nightStart || timeOfDay < morningEnd - 0.5) {
                targetLampIntensity = peakLampLightIntensity;
                targetLampEmissive = peakLampEmissiveIntensity;
            } else if (timeOfDay >= morningEnd - 0.5 && timeOfDay < morningEnd) {
                const factor = (timeOfDay - (morningEnd - 0.5)) / 0.5;
                targetLampIntensity = THREE.MathUtils.lerp(peakLampLightIntensity, 0, factor);
                targetLampEmissive = THREE.MathUtils.lerp(peakLampEmissiveIntensity, 0, factor);
            }

            if (targetLampIntensity > 0.05) {
                targetLampIntensity += Math.sin(time * 4.2 + tileData.z * 0.3) * 0.10 * targetLampIntensity;
                targetLampIntensity = Math.max(0.02, targetLampIntensity);
                targetLampEmissive = targetLampIntensity * 0.80;
            }

            pierLight.intensity = THREE.MathUtils.lerp(pierLight.intensity, targetLampIntensity, 0.1);
            pierShadeMat.emissiveIntensity = THREE.MathUtils.lerp(pierShadeMat.emissiveIntensity, targetLampEmissive, 0.1);
            pierLight.visible = pierLight.intensity > 0.01;
            pierShadeMat.needsUpdate = true;
        }
    };

    harbourGroup.castShadow = true;
    harbourGroup.traverse(child => {
        if (child.isMesh) {
            child.castShadow = true;
            child.receiveShadow = true;
        }
    });

    return harbourGroup;
};

## src\components\HexMap\buildings\models\createHouseModel.js ##
// src/components/HexMap/buildings/models/createHouseModel.js
import * as THREE from 'three';
import { BUILDING_TYPES } from '../BuildingTypes'
import { getCachedMaterial } from '../utils/materialManager'; // Adjust path

const HOUSE_WALL_COLOR = 0xD2B48C;
const HOUSE_ROOF_COLOR = 0xA52A2A;
const HOUSE_DOOR_COLOR = 0x8B4513;
const HOUSE_WINDOW_COLOR = 0xADD8E6;
const HOUSE_WINDOW_EMISSIVE_COLOR = 0xFFFFAA;
const HOUSE_LAMP_EMISSIVE_COLOR = 0xFFE082;
const HOUSE_FRAME_COLOR = 0x7A5230;
const CHIMNEY_COLOR = 0x8B4513;
const ROOF_PANEL_THICKNESS = 0.04;
const LAMP_POST_COLOR = 0x505050;
const LAMP_SHADE_COLOR = 0xF0E68C;

export const createHouseModel = (tileY) => {
    const houseGroup = new THREE.Group();
    houseGroup.userData.isBuilding = true;
    houseGroup.userData.buildingType = BUILDING_TYPES.HOUSE;

    const baseHeight = 0.6;
    const baseWidth = 0.7;
    const baseDepth = 0.6;

    const wallMaterial = getCachedMaterial(HOUSE_WALL_COLOR, { roughness: 0.8, metalness: 0.1 });
    const baseGeo = new THREE.BoxGeometry(baseWidth, baseHeight, baseDepth);
    const baseMesh = new THREE.Mesh(baseGeo, wallMaterial);
    baseMesh.position.y = tileY + baseHeight / 2;
    baseMesh.castShadow = true;
    baseMesh.receiveShadow = true;
    houseGroup.add(baseMesh);

    const roofMaterial = getCachedMaterial(HOUSE_ROOF_COLOR, { roughness: 0.7, metalness: 0.1 });
    roofMaterial.userData = { isRoof: true };
    const frameMaterial = getCachedMaterial(HOUSE_FRAME_COLOR, { roughness: 0.8 });

    const roofOverhangX = 0.05;
    const roofOverhangZ = 0.05;
    const roofPitchHeight = 0.35;

    const panelCuboidLength = baseDepth + 2 * roofOverhangZ;
    const panelCuboidWidth = Math.sqrt(Math.pow(baseWidth / 2 + roofOverhangX, 2) + Math.pow(roofPitchHeight, 2));

    const roofPanelGeo = new THREE.BoxGeometry(panelCuboidWidth, ROOF_PANEL_THICKNESS, panelCuboidLength);
    const slopeAngle = Math.atan2(roofPitchHeight, baseWidth / 2 + roofOverhangX);

    const panel1CenterX = (baseWidth / 2 + roofOverhangX - ROOF_PANEL_THICKNESS * Math.sin(slopeAngle)) / 2;
    const panel2CenterX = -(baseWidth / 2 + roofOverhangX - ROOF_PANEL_THICKNESS * Math.sin(slopeAngle)) / 2;
    const panelCenterY = tileY + baseHeight + (roofPitchHeight / 2) - (ROOF_PANEL_THICKNESS * Math.cos(slopeAngle)) / 4;

    const roofPanel1 = new THREE.Mesh(roofPanelGeo, roofMaterial);
    roofPanel1.userData.isRoof = true;
    roofPanel1.castShadow = true;
    roofPanel1.position.set(panel1CenterX, panelCenterY, 0);
    roofPanel1.rotation.z = -slopeAngle;
    houseGroup.add(roofPanel1);

    const roofPanel2 = new THREE.Mesh(roofPanelGeo, roofMaterial);
    roofPanel2.userData.isRoof = true;
    roofPanel2.castShadow = true;
    roofPanel2.position.set(panel2CenterX, panelCenterY, 0);
    roofPanel2.rotation.z = slopeAngle;
    houseGroup.add(roofPanel2);

    const ridgeCapLength = panelCuboidLength;
    const ridgeCapWidth = ROOF_PANEL_THICKNESS * 1.5;
    const ridgeCapHeight = ROOF_PANEL_THICKNESS * 1.2;
    const ridgeCapGeo = new THREE.BoxGeometry(ridgeCapWidth, ridgeCapHeight, ridgeCapLength);
    const ridgeCapMesh = new THREE.Mesh(ridgeCapGeo, frameMaterial);
    ridgeCapMesh.userData.isRoof = true;
    ridgeCapMesh.position.set(0, tileY + baseHeight + roofPitchHeight + ROOF_PANEL_THICKNESS / 2 - ridgeCapHeight / 3, 0);
    ridgeCapMesh.castShadow = true;
    houseGroup.add(ridgeCapMesh);

    const gableGeo = new THREE.BufferGeometry();
    const gableVertices = new Float32Array([
        -baseWidth / 2, baseHeight, baseDepth / 2,
        baseWidth / 2, baseHeight, baseDepth / 2,
        0, baseHeight + roofPitchHeight, baseDepth / 2,
        baseWidth / 2, baseHeight, -baseDepth / 2,
        -baseWidth / 2, baseHeight, -baseDepth / 2,
        0, baseHeight + roofPitchHeight, -baseDepth / 2,
    ]);
    for (let i = 0; i < gableVertices.length / 3; i++) {
        gableVertices[i * 3 + 1] += tileY;
    }
    gableGeo.setAttribute('position', new THREE.BufferAttribute(gableVertices, 3));
    gableGeo.computeVertexNormals();
    const gableMesh = new THREE.Mesh(gableGeo, wallMaterial);
    gableMesh.castShadow = true;
    houseGroup.add(gableMesh);

    const doorHeight = 0.35;
    const doorWidth = 0.15;
    const doorDepth = 0.03;
    const doorMaterial = getCachedMaterial(HOUSE_DOOR_COLOR, { roughness: 0.9 });
    const doorGeo = new THREE.BoxGeometry(doorWidth, doorHeight, doorDepth);
    const doorMesh = new THREE.Mesh(doorGeo, doorMaterial);
    doorMesh.position.set(0, tileY + doorHeight / 2, baseDepth / 2 - doorDepth / 2 + 0.001);
    doorMesh.castShadow = true;
    houseGroup.add(doorMesh);

    const frameThickness = 0.025;
    const doorFrameSideGeo = new THREE.BoxGeometry(frameThickness, doorHeight + frameThickness, frameThickness);
    const doorFrameTopGeo = new THREE.BoxGeometry(doorWidth + frameThickness * 2, frameThickness, frameThickness);

    const doorFrameLeft = new THREE.Mesh(doorFrameSideGeo, frameMaterial);
    doorFrameLeft.position.set(-doorWidth / 2 - frameThickness / 2, tileY + (doorHeight + frameThickness) / 2, baseDepth / 2 + 0.005);
    houseGroup.add(doorFrameLeft);

    const doorFrameRight = new THREE.Mesh(doorFrameSideGeo, frameMaterial);
    doorFrameRight.position.set(doorWidth / 2 + frameThickness / 2, tileY + (doorHeight + frameThickness) / 2, baseDepth / 2 + 0.005);
    houseGroup.add(doorFrameRight);

    const doorFrameTop = new THREE.Mesh(doorFrameTopGeo, frameMaterial);
    doorFrameTop.position.set(0, tileY + doorHeight + frameThickness / 2, baseDepth / 2 + 0.005);
    houseGroup.add(doorFrameTop);

    const windowSize = 0.15;
    const windowDepth = 0.02;
    const windowGlassMaterial = getCachedMaterial(HOUSE_WINDOW_COLOR, {
        roughness: 0.2,
        transparent: true,
        opacity: 0.6,
        side: THREE.DoubleSide,
        emissive: HOUSE_WINDOW_EMISSIVE_COLOR,
        emissiveIntensity: 0.0
    }, true); // Mark as special emissive if it has unique animation logic
    const windowGlassGeo = new THREE.BoxGeometry(windowSize, windowSize, windowDepth / 2);

    const createdWindowGlassMaterials = [windowGlassMaterial];

    const createFramedWindow = (posX, posY, posZ, rotY = 0) => {
        const windowGroup = new THREE.Group();
        windowGroup.position.set(posX, posY, posZ);
        windowGroup.rotation.y = rotY;
        const glass = new THREE.Mesh(windowGlassGeo, windowGlassMaterial);
        windowGroup.add(glass);
        const frameSideGeo = new THREE.BoxGeometry(frameThickness, windowSize + frameThickness * 2, frameThickness);
        const frameTopBottomGeo = new THREE.BoxGeometry(windowSize + frameThickness * 2, frameThickness, frameThickness);
        const frameLeft = new THREE.Mesh(frameSideGeo, frameMaterial);
        frameLeft.position.x = -windowSize / 2 - frameThickness / 2;
        windowGroup.add(frameLeft);
        const frameRight = new THREE.Mesh(frameSideGeo, frameMaterial);
        frameRight.position.x = windowSize / 2 + frameThickness / 2;
        windowGroup.add(frameRight);
        const frameTop = new THREE.Mesh(frameTopBottomGeo, frameMaterial);
        frameTop.position.y = windowSize / 2 + frameThickness / 2;
        windowGroup.add(frameTop);
        const frameBottom = new THREE.Mesh(frameTopBottomGeo, frameMaterial);
        frameBottom.position.y = -windowSize / 2 - frameThickness / 2;
        windowGroup.add(frameBottom);
        const sillGeo = new THREE.BoxGeometry(windowSize + frameThickness * 3, frameThickness * 0.8, frameThickness * 1.5);
        const sill = new THREE.Mesh(sillGeo, frameMaterial);
        sill.position.y = -windowSize / 2 - frameThickness;
        sill.position.z = frameThickness * 0.5;
        windowGroup.add(sill);
        windowGroup.castShadow = true;
        return windowGroup;
    };

    const windowYPos = tileY + baseHeight / 1.7;
    const window1 = createFramedWindow(baseWidth / 2 + frameThickness / 2, windowYPos, 0, Math.PI / 2);
    houseGroup.add(window1);
    const window2 = createFramedWindow(-baseWidth / 2 - frameThickness / 2, windowYPos, 0, -Math.PI / 2);
    houseGroup.add(window2);

    const chimneyWidth = 0.12;
    const chimneyDepth = 0.12;
    const chimneyHeight = 0.4;
    const chimneyMaterial = getCachedMaterial(CHIMNEY_COLOR, { roughness: 0.85 });
    chimneyMaterial.userData = { isRoof: true };
    const chimneyGeo = new THREE.BoxGeometry(chimneyWidth, chimneyHeight, chimneyDepth);
    const chimneyMesh = new THREE.Mesh(chimneyGeo, chimneyMaterial);
    const chimneyPosX = baseWidth / 4;
    chimneyMesh.position.set(
        chimneyPosX,
        tileY + baseHeight + roofPitchHeight - chimneyHeight * 0.1 + ROOF_PANEL_THICKNESS,
        -baseDepth / 4
    );
    chimneyMesh.castShadow = true;
    houseGroup.add(chimneyMesh);

    const lampGroup = new THREE.Group();
    const lampPostHeight = 0.25;
    const lampPostRadius = 0.01;
    const lampPostMaterial = getCachedMaterial(LAMP_POST_COLOR, { roughness: 0.6 });
    const lampPostGeo = new THREE.CylinderGeometry(lampPostRadius, lampPostRadius, lampPostHeight, 6);
    const lampPost = new THREE.Mesh(lampPostGeo, lampPostMaterial);
    lampPost.position.y = lampPostHeight / 2;
    lampGroup.add(lampPost);
    const lampShadeSize = 0.06;
    const lampShadeMaterial = getCachedMaterial(LAMP_SHADE_COLOR, {
        roughness: 0.7,
        emissive: HOUSE_LAMP_EMISSIVE_COLOR,
        emissiveIntensity: 0.0
    }, true); // Mark as special emissive
    lampShadeMaterial.userData = { isRoof: true, isLampShade: true };
    const lampShadeGeo = new THREE.BoxGeometry(lampShadeSize, lampShadeSize * 0.8, lampShadeSize);
    const lampShade = new THREE.Mesh(lampShadeGeo, lampShadeMaterial);
    lampShade.position.y = lampPostHeight + (lampShadeSize * 0.8) / 2 - 0.01;
    lampGroup.add(lampShade);
    const doorLampLight = new THREE.PointLight(HOUSE_LAMP_EMISSIVE_COLOR, 0, 0.8, 1.5);
    doorLampLight.position.y = lampShade.position.y;
    doorLampLight.castShadow = false;
    lampGroup.add(doorLampLight);
    const lampSideMultiplier = 1;
    lampGroup.position.set(
        (doorWidth / 2 + frameThickness + lampPostRadius + 0.03) * lampSideMultiplier,
        tileY,
        baseDepth / 2 + 0.02
    );
    lampGroup.castShadow = true;
    houseGroup.add(lampGroup);
    houseGroup.userData.doorLampLight = doorLampLight;
    houseGroup.userData.doorLampShadeMaterial = lampShadeMaterial;

    houseGroup.userData.animate = (time, timeOfDay) => {
        let targetWindowIntensity = 0.0;
        let targetLampIntensity = 0.0;
        let targetLampEmissive = 0.0;
        const eveningStart = 17.5;
        const nightStart = 19.5;
        const morningEnd = 7.0;
        const peakWindowIntensity = 0.8;
        const peakLampLightIntensity = 0.7;
        const peakLampEmissiveIntensity = 0.6;
        if (timeOfDay >= eveningStart && timeOfDay < nightStart) {
            const factor = (timeOfDay - eveningStart) / (nightStart - eveningStart);
            targetWindowIntensity = THREE.MathUtils.lerp(0, peakWindowIntensity, factor);
            targetLampIntensity = THREE.MathUtils.lerp(0, peakLampLightIntensity, factor);
            targetLampEmissive = THREE.MathUtils.lerp(0, peakLampEmissiveIntensity, factor);
        } else if (timeOfDay >= nightStart || timeOfDay < morningEnd - 1) {
            targetWindowIntensity = peakWindowIntensity;
            targetLampIntensity = peakLampLightIntensity;
            targetLampEmissive = peakLampEmissiveIntensity;
        } else if (timeOfDay >= morningEnd - 1 && timeOfDay < morningEnd) {
            const factor = (timeOfDay - (morningEnd - 1)) / 1;
            targetWindowIntensity = THREE.MathUtils.lerp(peakWindowIntensity, 0, factor);
            targetLampIntensity = THREE.MathUtils.lerp(peakLampLightIntensity, 0, factor);
            targetLampEmissive = THREE.MathUtils.lerp(peakLampEmissiveIntensity, 0, factor);
        }
        if (targetWindowIntensity > 0.05) {
            targetWindowIntensity += Math.sin(time * 5 + houseGroup.id * 0.5) * 0.08 * targetWindowIntensity;
            targetWindowIntensity = Math.max(0.05, targetWindowIntensity);
        }
        if (targetLampIntensity > 0.05) {
            targetLampIntensity += Math.sin(time * 4.5 + houseGroup.id * 0.3) * 0.1 * targetLampIntensity;
            targetLampIntensity = Math.max(0.03, targetLampIntensity);
            targetLampEmissive = targetLampIntensity * 0.8;
        }
        if (createdWindowGlassMaterials.length > 0) {
            const material = createdWindowGlassMaterials[0];
            material.emissiveIntensity = THREE.MathUtils.lerp(material.emissiveIntensity, targetWindowIntensity, 0.1);
            material.needsUpdate = true;
        }
        const lampLight = houseGroup.userData.doorLampLight;
        const lampShadeMat = houseGroup.userData.doorLampShadeMaterial;
        if (lampLight && lampShadeMat) {
            lampLight.intensity = THREE.MathUtils.lerp(lampLight.intensity, targetLampIntensity, 0.1);
            lampShadeMat.emissiveIntensity = THREE.MathUtils.lerp(lampShadeMat.emissiveIntensity, targetLampEmissive, 0.1);
            lampLight.visible = lampLight.intensity > 0.01;
            lampShadeMat.needsUpdate = true;
        }
    };
    return houseGroup;
};

## src\components\HexMap\buildings\models\createMineModel.js ##
// src/components/HexMap/buildings/models/createMineModel.js
import * as THREE from 'three';
import { BUILDING_TYPES } from '../BuildingTypes';
import { getCachedMaterial } from '../utils/materialManager';
import { createRock as createSmallRock } from '../../utils/rockUtils';

const MINE_WOOD_COLOR = 0x654321;
const MINE_ROCK_COLOR = 0x888480;
const MINE_OPENING_COLOR = 0x101010;
const TOOL_HANDLE_COLOR = 0x964B00;
const TOOL_METAL_COLOR = 0x777777;
const ROOF_COLOR = 0x654321;
const LAMP_POST_COLOR = 0x4B3A26; // Dark, weathered wood for mine lamp post
const LAMP_SHADE_COLOR = 0xD2B48C; // Old tan/canvas like shade
const MINE_LAMP_EMISSIVE_COLOR = 0xFFB74D; // Orange-yellow, less bright than house

export const createMineModel = (tileY) => {
    const mineGroup = new THREE.Group();
    mineGroup.userData.isBuilding = true;
    mineGroup.userData.buildingType = BUILDING_TYPES.MINE;

    const woodMaterial = getCachedMaterial(MINE_WOOD_COLOR, { roughness: 0.85, metalness: 0.05 });
    woodMaterial.userData = { isRoof: true };
    const woodMaterial2 = getCachedMaterial(MINE_WOOD_COLOR, { roughness: 0.85, metalness: 0.05 });
    const largeRockMaterial = getCachedMaterial(MINE_ROCK_COLOR, { roughness: 0.9, metalness: 0.1, flatShading: true });
    largeRockMaterial.userData = { isRoof: true };
    const roofMaterial = getCachedMaterial(ROOF_COLOR, { roughness: 0.9, metalness: 0.1, flatShading: true });
    roofMaterial.userData = { isRoof: true };
    const openingMaterial = getCachedMaterial(MINE_OPENING_COLOR, { roughness: 1.0, color: MINE_OPENING_COLOR });

    const mainRockGroup = new THREE.Group();
    const baseRockRadius = 0.5;
    const baseRockGeo = new THREE.DodecahedronGeometry(baseRockRadius, 0);
    const baseRockMesh = new THREE.Mesh(baseRockGeo, largeRockMaterial);
    baseRockMesh.scale.set(1.1, 0.8, 1.0);
    baseRockMesh.position.y = tileY + (baseRockRadius * 0.6 * 0.5) - 0.05;
    mainRockGroup.add(baseRockMesh);
    mainRockGroup.position.z = 0.15;
    mineGroup.add(mainRockGroup);

    const frameHeight = 0.45;
    const frameWidth = 0.35;
    const beamThickness = 0.05;
    const roofHeight = 0.5;
    const roofAngle = Math.PI / 8;

    const verticalBeamGeo = new THREE.BoxGeometry(beamThickness, frameHeight, beamThickness);
    const horizontalBeamGeo = new THREE.BoxGeometry(frameWidth + beamThickness * 1.5, beamThickness, beamThickness);
    const roofGeo = new THREE.BoxGeometry(frameWidth + beamThickness * 2, beamThickness / 2, roofHeight);
    const wallGeo = new THREE.BoxGeometry(beamThickness / 2, frameHeight, roofHeight);

    const entranceZPos = mainRockGroup.position.z - (baseRockRadius * baseRockMesh.scale.z * 0.85) - 0.24;
    const entranceOffsetY = tileY + 0.01;

    const entranceFrameGroup = new THREE.Group();
    entranceFrameGroup.position.z = entranceZPos;
    mineGroup.add(entranceFrameGroup);

    const leftBeam = new THREE.Mesh(verticalBeamGeo, woodMaterial2);
    leftBeam.position.set(-frameWidth / 2, entranceOffsetY + frameHeight / 2, 0);
    entranceFrameGroup.add(leftBeam);

    const leftWall = new THREE.Mesh(wallGeo, woodMaterial2);
    leftWall.position.set(-frameWidth / 2, entranceOffsetY + frameHeight / 2 - Math.sin(roofAngle) * roofHeight / 2 + beamThickness / 2, roofHeight / 2);
    leftWall.rotation.x = roofAngle;
    entranceFrameGroup.add(leftWall);

    const rightBeam = new THREE.Mesh(verticalBeamGeo, woodMaterial2);
    rightBeam.position.set(frameWidth / 2, entranceOffsetY + frameHeight / 2, 0);
    entranceFrameGroup.add(rightBeam);

    const rightWall = new THREE.Mesh(wallGeo, woodMaterial2);
    rightWall.position.set(frameWidth / 2, entranceOffsetY + frameHeight / 2 - Math.sin(roofAngle) * roofHeight / 2 + beamThickness / 2, roofHeight / 2);
    rightWall.rotation.x = roofAngle;
    entranceFrameGroup.add(rightWall);

    const topBeam = new THREE.Mesh(horizontalBeamGeo, woodMaterial);
    topBeam.position.set(0, entranceOffsetY + frameHeight + beamThickness / 2, 0);
    entranceFrameGroup.add(topBeam);

    const roofMesh = new THREE.Mesh(roofGeo, roofMaterial);
    roofMesh.position.set(0, entranceOffsetY + frameHeight + beamThickness / 2 - Math.sin(roofAngle) * (roofHeight / 2) + 0.01, roofHeight / 2);
    roofMesh.rotation.x = roofAngle;
    entranceFrameGroup.add(roofMesh);

    const supportAngle = Math.PI / 6;
    const supportLength = frameHeight * 0.6 / Math.cos(supportAngle);
    const supportBeamGeo = new THREE.BoxGeometry(beamThickness, supportLength, beamThickness);

    const leftSupport = new THREE.Mesh(supportBeamGeo, woodMaterial);
    leftSupport.position.set(-frameWidth / 2 - beamThickness * 0.8, entranceOffsetY + frameHeight * 0.3, beamThickness * 0.5);
    leftSupport.rotation.z = supportAngle;
    entranceFrameGroup.add(leftSupport);

    const rightSupport = new THREE.Mesh(supportBeamGeo, woodMaterial);
    rightSupport.position.set(frameWidth / 2 + beamThickness * 0.8, entranceOffsetY + frameHeight * 0.3, beamThickness * 0.5);
    rightSupport.rotation.z = -supportAngle;
    entranceFrameGroup.add(rightSupport);

    const openingGeo = new THREE.BoxGeometry(frameWidth, frameHeight, roofHeight * 0.8);
    const openingMesh = new THREE.Mesh(openingGeo, openingMaterial);
    openingMesh.position.set(
        0,
        entranceOffsetY + (frameHeight / 2) - (Math.sin(roofAngle) * roofHeight / 2),
        (roofHeight * 0.8) / 2 + Math.cos(roofAngle) * (beamThickness)
    );
    openingMesh.rotation.x = roofAngle;
    entranceFrameGroup.add(openingMesh);

    const toolHandleMaterial = getCachedMaterial(TOOL_HANDLE_COLOR, { roughness: 0.7 });
    const toolMetalMaterial = getCachedMaterial(TOOL_METAL_COLOR, { roughness: 0.5, metalness: 0.6 });
    toolHandleMaterial.userData = { isRoof: true };
    toolMetalMaterial.userData = { isRoof: true };

    const spadeGroup = new THREE.Group();
    const spadeHandleGeo = new THREE.CylinderGeometry(0.01, 0.01, 0.35, 6);
    const spadeHandle = new THREE.Mesh(spadeHandleGeo, toolHandleMaterial);
    spadeHandle.position.y = 0.35 / 2;
    spadeGroup.add(spadeHandle);
    const spadeHeadGeo = new THREE.PlaneGeometry(0.08, 0.12);
    const spadeHead = new THREE.Mesh(spadeHeadGeo, toolMetalMaterial);
    spadeHead.position.y = 0;
    spadeHandle.add(spadeHead);
    spadeGroup.position.set(leftBeam.position.x - beamThickness * 0.5, tileY + 0.18, leftBeam.position.z + beamThickness * 0.5);
    spadeGroup.rotation.z = Math.PI / 9;
    spadeGroup.rotation.y = Math.PI / 5;
    entranceFrameGroup.add(spadeGroup);

    const pickaxeGroup = new THREE.Group();
    const pickHandleGeo = new THREE.CylinderGeometry(0.012, 0.012, 0.3, 6);
    const pickHandle = new THREE.Mesh(pickHandleGeo, toolHandleMaterial);
    pickHandle.position.y = 0.3 / 2;
    pickaxeGroup.add(pickHandle);
    const pickHeadPartWidth = 0.12;
    const pickHeadPartGeo = new THREE.BoxGeometry(pickHeadPartWidth, 0.025, 0.02);
    const pickHeadPart1 = new THREE.Mesh(pickHeadPartGeo, toolMetalMaterial);
    pickHeadPart1.position.set(pickHeadPartWidth / 2 - 0.01, 0, 0);
    pickHeadPart1.rotation.z = Math.PI / 10;
    pickHandle.add(pickHeadPart1);
    const pickHeadPart2 = new THREE.Mesh(pickHeadPartGeo, toolMetalMaterial);
    pickHeadPart2.position.set(-pickHeadPartWidth / 2 + 0.01, 0, 0.005);
    pickHeadPart2.rotation.z = -Math.PI / 10;
    pickHandle.add(pickHeadPart2);
    pickaxeGroup.position.set(rightBeam.position.x + beamThickness * 0.5, tileY + 0.2, rightBeam.position.z + beamThickness * 0.5);
    pickaxeGroup.rotation.z = -Math.PI / 8;
    pickaxeGroup.rotation.y = -Math.PI / 6;
    entranceFrameGroup.add(pickaxeGroup);

    const numSmallRocks = 4 + Math.floor(Math.random() * 4);
    for (let i = 0; i < numSmallRocks; i++) {
        const smallRock = createSmallRock();
        const angle = (Math.random() * Math.PI * 1.4) - (Math.PI * 0.2);
        const dist = baseRockRadius * (mainRockGroup.scale.x || 1) * (0.6 + Math.random() * 0.6);
        const rockSizeY = smallRock.geometry.parameters.height ? smallRock.geometry.parameters.height : (smallRock.geometry.parameters.radius || 0.1) * 1.5;
        smallRock.position.set(
            mainRockGroup.position.x + Math.cos(angle) * dist,
            tileY + rockSizeY * 0.3,
            mainRockGroup.position.z + Math.sin(angle) * dist
        );
        smallRock.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
        smallRock.scale.set(0.5 + Math.random() * 0.4, 0.5 + Math.random() * 0.4, 0.5 + Math.random() * 0.4);
        mineGroup.add(smallRock);
    }

    const numPlanks = 2 + Math.floor(Math.random() * 3);
    const plankThickness = 0.02;
    const plankWidth = 0.08;
    for (let i = 0; i < numPlanks; i++) {
        const plankLength = 0.3 + Math.random() * 0.25;
        const plankGeo = new THREE.BoxGeometry(plankWidth, plankThickness, plankLength);
        const plank = new THREE.Mesh(plankGeo, woodMaterial);
        const side = Math.random() < 0.5 ? -1 : 1;
        const xOffset = side * (frameWidth * 0.3 + Math.random() * frameWidth * 0.5);
        const zOffset = Math.random() * 0.2 - 0.1;
        plank.position.set(
            xOffset,
            tileY + plankThickness / 2,
            zOffset
        );
        plank.rotation.x = (Math.random() - 0.5) * 0.1;
        plank.rotation.y = Math.random() * Math.PI * 2;
        plank.rotation.z = (Math.random() - 0.5) * 0.1;
        plank.castShadow = true;
        entranceFrameGroup.add(plank);
    }

    const mineLampGroup = new THREE.Group();
    const lampPostMaterial = getCachedMaterial(LAMP_POST_COLOR, { roughness: 0.7 });
    const lampShadeMaterial = getCachedMaterial(LAMP_SHADE_COLOR, {
        roughness: 0.8,
        emissive: MINE_LAMP_EMISSIVE_COLOR,
        emissiveIntensity: 0.0
    }, true);
    lampShadeMaterial.userData = { isRoof: true, isLampShade: true };

    const lampPostGeo = new THREE.BoxGeometry(beamThickness * 0.8, frameHeight * 0.6, beamThickness * 0.8);
    const lampPost = new THREE.Mesh(lampPostGeo, lampPostMaterial);
    lampPost.position.y = (frameHeight * 0.6) / 2;
    lampPost.userData.isMineLampComponent = true; // Flag for snow logic
    mineLampGroup.add(lampPost);

    const lampArmGeo = new THREE.BoxGeometry(beamThickness * 0.6, beamThickness * 0.6, 0.15);
    const lampArm = new THREE.Mesh(lampArmGeo, lampPostMaterial);
    lampArm.position.set(0, frameHeight * 0.6 - beamThickness * 0.3, - 0.15 / 2 + beamThickness * 0.4);
    lampArm.userData.isMineLampComponent = true; // Flag for snow logic
    lampPost.add(lampArm);

    const lampShadeSize = 0.07;
    const lampShadeGeo = new THREE.CylinderGeometry(lampShadeSize * 0.6, lampShadeSize, lampShadeSize * 0.8, 6);
    const lampShade = new THREE.Mesh(lampShadeGeo, lampShadeMaterial);
    lampShade.position.set(0, -lampShadeSize * 0.8 / 2 - 0.01, -0.08);
    lampArm.add(lampShade);

    const mineLampLight = new THREE.PointLight(MINE_LAMP_EMISSIVE_COLOR, 0, 0.7, 1.2); // Start with 0 intensity

    // --- Shadow Configuration for Mine Lamp ---
    mineLampLight.castShadow = true; // Enable shadows
    mineLampLight.shadow.mapSize.width = 256; // Lower resolution for performance
    mineLampLight.shadow.mapSize.height = 256;
    mineLampLight.shadow.camera.near = 0.05; // Must be > 0
    mineLampLight.shadow.camera.far = mineLampLight.distance > 0 ? mineLampLight.distance * 1.5 : 2; // Adjust based on light's effective distance
    mineLampLight.shadow.bias = -0.005; // Adjust if shadow acne occurs
    // mineLampLight.shadow.normalBias = 0.02; // Adjust if needed

    // Position light relative to the shade. Since shade is child of arm, child of post, child of mineLampGroup...
    // It's easier to add the light to the same parent as the shade (lampArm) and position it locally.
    // Or, calculate world position once and add light to a more global group.
    // For now, let's add it to entranceFrameGroup and update its position.
    // Get initial world position of shade to set light position:
    const tempShadeWorldPos = new THREE.Vector3();
    lampShade.getWorldPosition(tempShadeWorldPos); // Calculate it after lampShade is added to its parents
    mineLampLight.position.copy(tempShadeWorldPos);
    mineLampLight.position.y -= 0.02;

    entranceFrameGroup.add(mineLampLight);

    const lampSide = Math.random() < 0.5 ? -1 : 1;
    mineLampGroup.position.set(
        (frameWidth / 2 + beamThickness * 0.5 + 0.02) * lampSide,
        entranceOffsetY,
        -beamThickness / 2
    );
    mineLampGroup.castShadow = true; // The lamp post itself can cast shadow
    entranceFrameGroup.add(mineLampGroup);

    mineGroup.userData.mineLampLight = mineLampLight;
    mineGroup.userData.mineLampShadeMaterial = lampShadeMaterial;
    mineGroup.userData.lampShadeForLightPosition = lampShade; // Store ref to update light pos if shade moves

    mineGroup.userData.animate = (time, timeOfDay) => {
        let targetLampIntensity = 0.0;
        let targetLampEmissive = 0.0;

        const eveningStart = 18.0;
        const nightStart = 19.5;
        const morningEnd = 6.5;
        const peakLampLightIntensity = 0.5; // Reduced a bit for performance if many shadow casters
        const peakLampEmissiveIntensity = 0.4;

        if (timeOfDay >= eveningStart && timeOfDay < nightStart) {
            const factor = (timeOfDay - eveningStart) / (nightStart - eveningStart);
            targetLampIntensity = THREE.MathUtils.lerp(0, peakLampLightIntensity, factor);
            targetLampEmissive = THREE.MathUtils.lerp(0, peakLampEmissiveIntensity, factor);
        } else if (timeOfDay >= nightStart || timeOfDay < morningEnd - 0.5) {
            targetLampIntensity = peakLampLightIntensity;
            targetLampEmissive = peakLampEmissiveIntensity;
        } else if (timeOfDay >= morningEnd - 0.5 && timeOfDay < morningEnd) {
            const factor = (timeOfDay - (morningEnd - 0.5)) / 0.5;
            targetLampIntensity = THREE.MathUtils.lerp(peakLampLightIntensity, 0, factor);
            targetLampEmissive = THREE.MathUtils.lerp(peakLampEmissiveIntensity, 0, factor);
        }

        if (targetLampIntensity > 0.05) {
            targetLampIntensity += Math.sin(time * 3.5 + mineGroup.id * 0.4) * 0.08 * targetLampIntensity;
            targetLampIntensity = Math.max(0.02, targetLampIntensity);
            targetLampEmissive = targetLampIntensity * 0.7;
        }

        const lampLight = mineGroup.userData.mineLampLight;
        const lampShadeMat = mineGroup.userData.mineLampShadeMaterial;
        const lampShadeMesh = mineGroup.userData.lampShadeForLightPosition;

        if (lampLight && lampShadeMat && lampShadeMesh) {
            lampLight.intensity = THREE.MathUtils.lerp(lampLight.intensity, targetLampIntensity, 0.1);
            lampShadeMat.emissiveIntensity = THREE.MathUtils.lerp(lampShadeMat.emissiveIntensity, targetLampEmissive, 0.1);
            lampLight.visible = lampLight.intensity > 0.01;

            // Continuously update light position from the shade's world position
            // This is important if the mineLampGroup or its parents can be rotated or moved
            lampShadeMesh.getWorldPosition(lampLight.position);
            lampLight.position.y -= 0.02; // Keep it slightly below the shade

            lampShadeMat.needsUpdate = true;
        }
    };

    mineGroup.castShadow = true;
    mineGroup.traverse(child => {
        if (child.isMesh) {
            child.castShadow = true;
            child.receiveShadow = true;
        }
    });

    return mineGroup;
};

## src\components\HexMap\buildings\models\index.js ##
// src/components/HexMap/buildings/models/index.js
import { createHouseModel } from './createHouseModel';
import { createCampfireModel } from './createCampfireModel';
import { createFarmModel } from './createFarmModel';
import { createMineModel } from './createMineModel';
import { createHarbourModel } from './createHarbourModel'; // Ensure this line is correct

export {
    createHouseModel,
    createCampfireModel,
    createFarmModel,
    createMineModel,
    createHarbourModel, // And this line
};

## src\components\HexMap\buildings\utils\materialManager.js ##
// src/components/HexMap/buildings/utils/materialManager.js
import * as THREE from 'three';
import { SNOW_COVER_COLOR, MAX_SNOW_COVER_LERP_FACTOR, BUILDING_TYPES } from '../../constants'; // Adjust path

// Specific emissive colors to identify special materials that shouldn't be snowed over
// or have their own animation logic.
const FLAME_COLOR_ORANGE_HEX = 0xFFAA33;
const FLAME_COLOR_YELLOW_HEX = 0xFFFFAA;
const HOUSE_WINDOW_EMISSIVE_COLOR_HEX = 0xFFFFAA;
const HOUSE_LAMP_EMISSIVE_COLOR_HEX = 0xFFE082;
const MINE_LAMP_EMISSIVE_COLOR_HEX = 0xFFB74D;


const buildingMaterialsCache = new Map(); // Key: material, Value: { originalColor: Color, originalEmissive?: Color }

export const getCachedMaterial = (colorHex, props = {}, isSpecialEmissive = false) => {
    // For truly unique materials (like animated flames, specific lamp glows),
    // isSpecialEmissive = true bypasses caching or uses a more specific key if needed.
    // For now, we cache all non-flame/glow materials.
    const material = new THREE.MeshStandardMaterial({ color: colorHex, ...props });

    if (!isSpecialEmissive) { // Only cache standard, reusable materials
        const cacheEntry = { originalColor: material.color.clone() };
        if (material.emissive) {
            cacheEntry.originalEmissive = material.emissive.clone();
        }
        buildingMaterialsCache.set(material, cacheEntry);
    }
    return material;
};

export const updateBuildingInstanceSnow = (buildingInstance, snowAccumulationRatio) => {
    if (!buildingInstance || !buildingInstance.userData?.isBuilding) return;

    const snowColor = new THREE.Color(SNOW_COVER_COLOR);
    const buildingType = buildingInstance.userData.buildingType;

    let isCampfireLit = false;
    if (buildingType === BUILDING_TYPES.CAMPFIRE && typeof buildingInstance.userData.isLit === 'function') {
        isCampfireLit = buildingInstance.userData.isLit();
    }

    let isHouseLampOn = false;
    if (buildingType === BUILDING_TYPES.HOUSE && buildingInstance.userData.doorLampLight) {
        isHouseLampOn = buildingInstance.userData.doorLampLight.intensity > 0.05;
    }

    let isMineLampOn = false;
    if (buildingType === BUILDING_TYPES.MINE && buildingInstance.userData.mineLampLight) {
        isMineLampOn = buildingInstance.userData.mineLampLight.intensity > 0.05;
    }

    buildingInstance.traverse((node) => {
        if (node.isMesh && node.material) {
            const materials = Array.isArray(node.material) ? node.material : [node.material];
            materials.forEach(material => {
                // Skip materials that handle their own appearance (emissive parts of lights/flames)
                if (material.emissive && material.emissiveIntensity > 0) {
                    const emissiveHex = material.emissive.getHex();
                    if (
                        emissiveHex === FLAME_COLOR_ORANGE_HEX ||
                        emissiveHex === FLAME_COLOR_YELLOW_HEX ||
                        emissiveHex === HOUSE_WINDOW_EMISSIVE_COLOR_HEX ||
                        (material.userData?.isLampShade && emissiveHex === HOUSE_LAMP_EMISSIVE_COLOR_HEX) ||
                        (material.userData?.isLampShade && emissiveHex === MINE_LAMP_EMISSIVE_COLOR_HEX)
                    ) {
                        return;
                    }
                }

                const cacheEntry = buildingMaterialsCache.get(material);
                if (cacheEntry) {
                    let currentLerpFactor = 0;
                    let effectiveSnowRatio = snowAccumulationRatio;

                    if (buildingType === BUILDING_TYPES.CAMPFIRE && isCampfireLit) {
                        effectiveSnowRatio *= 0.05;
                    }

                    // Check for house lamp post. The parent of doorLampLight is the lampGroup.
                    if (buildingType === BUILDING_TYPES.HOUSE &&
                        buildingInstance.userData.doorLampLight &&
                        node.parent === buildingInstance.userData.doorLampLight.parent && // Check if node is part of the lamp assembly
                        isHouseLampOn) {
                        effectiveSnowRatio *= 0.3;
                    }
                    // Use the userData flag for mine lamp components
                    if (node.userData?.isMineLampComponent && isMineLampOn) {
                        effectiveSnowRatio *= 0.3;
                    }


                    if (material.userData?.isRoof) {
                        currentLerpFactor = effectiveSnowRatio * MAX_SNOW_COVER_LERP_FACTOR;
                    } else {
                        currentLerpFactor = effectiveSnowRatio * MAX_SNOW_COVER_LERP_FACTOR * 0.25;
                    }
                    material.color.copy(cacheEntry.originalColor).lerp(snowColor, Math.min(currentLerpFactor, 1.0));
                    material.needsUpdate = true;
                }
            });
        }
    });
};

export const disposeAllCachedMaterials = () => {
    buildingMaterialsCache.forEach((value, material) => {
        material.dispose();
    });
    buildingMaterialsCache.clear();
    console.log("Disposed all cached building materials.");
};

## src\components\HexMap\hooks\useFoxes.js ##
// src/components/HexMap/hooks/useFoxes.js
import { useEffect, useRef, useState, useCallback } from 'react';
import * as THREE from 'three';
import {
    NUMBER_OF_FOXES, FOX_MAX_JUMP_HEIGHT_DIFFERENCE, TILE_TYPES, SEASONS,
    FOX_FOOTPRINT_TEXTURE_URL, FOX_FOOTPRINT_SIZE, FOX_FOOTPRINT_LIFETIME_SECONDS,
    FOX_FOOTPRINT_INTERVAL_SECONDS, FOX_FOOTPRINT_OPACITY, MIN_SNOW_FOR_FOOTPRINTS,
    FOX_FOOTPRINT_Y_OFFSET, TRANSPARENT_LAYER_Y // Import TRANSPARENT_LAYER_Y
} from '../constants';
import {
    createFoxModel, disposeFoxMaterials, FOX_SPEED, FOX_TURN_SPEED,
    FOX_MAX_LEG_SWING_X, FOX_LEG_ANIM_SPEED_FACTOR,
    FOX_HEAD_BOB_AMOUNT, FOX_HEAD_BOB_SPEED_FACTOR,
    FOX_TAIL_WAG_ANGLE_Z, FOX_TAIL_WAG_SPEED_FACTOR,
    FOX_HEAD_IDLE_TURN_Y_ANGLE, FOX_HEAD_IDLE_SPEED_FACTOR,
    FOX_TAIL_IDLE_SWISH_Z_ANGLE, FOX_TAIL_IDLE_SPEED_FACTOR
} from '../utils/foxUtils';

const ACTUAL_FOX_IDLE_TIME_MIN = 0.5;
const ACTUAL_FOX_IDLE_TIME_MAX = 2.5;
const STUCK_FOX_IDLE_TIME_MIN = 0.3;
const STUCK_FOX_IDLE_TIME_MAX = 0.8;
const FOX_MODEL_GROUND_OFFSET = 0.05; // This is how much the fox's origin is above the tile's y

const getTileKey = (c, r) => `${c},${r}`;

const getAdjacentTileCoordinates = (c, r, gridColumns, gridRows) => {
    const isOddRow = r % 2 === 1;
    const potentialNeighbors = [
        { nc: c + 1, nr: r }, { nc: c - 1, nr: r },
        { nc: isOddRow ? c + 1 : c, nr: r + 1 }, { nc: isOddRow ? c : c - 1, nr: r + 1 },
        { nc: isOddRow ? c + 1 : c, nr: r - 1 }, { nc: isOddRow ? c : c - 1, nr: r - 1 }
    ];
    return potentialNeighbors.filter(n =>
        n.nc >= 0 && n.nc < gridColumns && n.nr >= 0 && n.nr < gridRows
    );
};

const stepInterpolationMidpoint = (t, transitionWindow = 0.2) => {
    const midPoint = 0.5;
    const halfWindow = transitionWindow / 2;
    const startTransition = midPoint - halfWindow;
    const endTransition = midPoint + halfWindow;

    if (t <= startTransition) return 0;
    if (t >= endTransition) return 1;
    const progressInWindow = (t - startTransition) / transitionWindow;
    return progressInWindow < 0.5
        ? 2 * progressInWindow * progressInWindow
        : 1 - Math.pow(-2 * progressInWindow + 2, 2) / 2;
};

const useFoxes = (coreElements, landTiles, landTileMap, gridColumns, gridRows, season, snowAccumulationRatio) => {
    const [foxSystemData, setFoxSystemData] = useState(null);
    const foxesArrayRef = useRef([]);
    const textureLoaderRef = useRef(null);
    const footprintTextureRef = useRef(null);
    const footprintMaterialRef = useRef(null);
    const footprintGeometryRef = useRef(null);
    const footprintsGroupRef = useRef(null);
    const activeFootprintsRef = useRef([]);

    useEffect(() => {
        if (!coreElements || !coreElements.isReady || !coreElements.scene || !(coreElements.scene instanceof THREE.Scene) ||
            !landTiles || landTiles.length === 0 || !landTileMap || landTileMap.size === 0 ||
            gridColumns === undefined || gridRows === undefined) {
            if (foxSystemData) setFoxSystemData(null);
            return;
        }

        const { scene } = coreElements;
        textureLoaderRef.current = new THREE.TextureLoader();
        footprintTextureRef.current = textureLoaderRef.current.load(FOX_FOOTPRINT_TEXTURE_URL,
            () => console.log("Fox footprint texture loaded."),
            undefined,
            (err) => console.error("Error loading fox footprint texture:", err)
        );
        footprintMaterialRef.current = new THREE.MeshBasicMaterial({
            map: footprintTextureRef.current,
            transparent: true,
            opacity: FOX_FOOTPRINT_OPACITY,
            depthWrite: false,
            alphaTest: 0.1, // Adjust if needed for better edges
            side: THREE.DoubleSide, // Can be FrontSide if footprints are always on top
        });
        footprintGeometryRef.current = new THREE.PlaneGeometry(FOX_FOOTPRINT_SIZE, FOX_FOOTPRINT_SIZE);

        footprintsGroupRef.current = new THREE.Group();
        scene.add(footprintsGroupRef.current);

        const foxGroupInstance = new THREE.Group();
        foxGroupInstance.renderOrder = 0; // Ensure foxes render correctly with other elements
        scene.add(foxGroupInstance);

        // Clear previous foxes if any (e.g., from hot reload)
        foxesArrayRef.current.forEach(existingFox => {
            if (existingFox.model && existingFox.model.parent) {
                existingFox.model.parent.remove(existingFox.model);
                // Dispose geometry/material if fox models are unique, but foxUtils shares materials
            }
        });
        foxesArrayRef.current = [];

        for (let i = 0; i < NUMBER_OF_FOXES; i++) {
            const spawnTileIndex = Math.floor(Math.random() * landTiles.length);
            const spawnTile = landTiles[spawnTileIndex]; // spawnTile.y is the top surface of the land hex

            // Ensure spawn tile is not water, even though landTiles should filter this
            if (spawnTile.type === TILE_TYPES.DEEP_WATER || spawnTile.type === TILE_TYPES.SHALLOW_WATER) {
                console.warn("Fox tried to spawn on a water tile from landTiles array. Skipping this fox.", spawnTile);
                continue;
            }

            const foxModel = createFoxModel();

            // foxModel's origin is at its "feet" level conceptually.
            // spawnTile.y is the height of the tile.
            // FOX_MODEL_GROUND_OFFSET is any additional lift needed.
            foxModel.position.set(spawnTile.x, spawnTile.y + FOX_MODEL_GROUND_OFFSET, spawnTile.z);
            foxGroupInstance.add(foxModel);

            foxesArrayRef.current.push({
                model: foxModel,
                currentTile: spawnTile,
                startTileY: spawnTile.y, // Height of the current tile's surface
                targetTileY: spawnTile.y, // Height of the target tile's surface
                startPosition: foxModel.position.clone(),
                targetPosition: new THREE.Vector3().copy(foxModel.position),
                movementProgress: 0,
                state: 'idle',
                idleTimer: Math.random() * (ACTUAL_FOX_IDLE_TIME_MAX - ACTUAL_FOX_IDLE_TIME_MIN) + ACTUAL_FOX_IDLE_TIME_MIN,
                animationTime: Math.random() * 100,
                footprintCooldown: 0,
                nextFootprintSide: Math.random() < 0.5 ? 'left' : 'right',
            });
        }

        setFoxSystemData({
            foxGroup: foxGroupInstance,
            isReady: true
        });

        return () => {
            if (foxGroupInstance && scene && foxGroupInstance.parent === scene) scene.remove(foxGroupInstance);
            // disposeFoxMaterials(); // Materials are shared, dispose once globally if app closes
            foxesArrayRef.current = [];

            if (footprintsGroupRef.current && scene && footprintsGroupRef.current.parent === scene) {
                activeFootprintsRef.current.forEach(fp => footprintsGroupRef.current.remove(fp.mesh));
                scene.remove(footprintsGroupRef.current);
            }
            activeFootprintsRef.current = [];
            if (footprintGeometryRef.current) footprintGeometryRef.current.dispose();
            if (footprintMaterialRef.current) footprintMaterialRef.current.dispose();
            if (footprintTextureRef.current) footprintTextureRef.current.dispose();
            footprintGeometryRef.current = null;
            footprintMaterialRef.current = null;
            footprintTextureRef.current = null;
            footprintsGroupRef.current = null;
            setFoxSystemData(null);
        };
    }, [coreElements, landTiles, landTileMap, gridColumns, gridRows]); // Removed season, snowAccumulationRatio from main deps


    const updateFoxes = useCallback((deltaTime, elapsedTime) => {
        if (!foxSystemData || !foxSystemData.isReady || foxesArrayRef.current.length === 0 ||
            !landTileMap || !coreElements || !coreElements.isReady ||
            season === undefined || snowAccumulationRatio === undefined || // Keep these for footprint logic
            !footprintsGroupRef.current || !footprintMaterialRef.current || !footprintGeometryRef.current) {
            return;
        }

        const canLeaveFootprints = season === SEASONS.WINTER && snowAccumulationRatio >= MIN_SNOW_FOR_FOOTPRINTS;

        foxesArrayRef.current.forEach((fox) => {
            fox.animationTime += deltaTime;
            if (fox.footprintCooldown > 0) fox.footprintCooldown -= deltaTime;

            if (fox.state === 'idle') {
                fox.idleTimer -= deltaTime;
                if (fox.idleTimer <= 0) {
                    fox.state = 'wandering';
                }
            }

            if (fox.state === 'wandering') {
                const adjacentCoords = getAdjacentTileCoordinates(fox.currentTile.c, fox.currentTile.r, gridColumns, gridRows);
                const possibleTargets = [];
                adjacentCoords.forEach(coord => {
                    const key = getTileKey(coord.nc, coord.nr);
                    const potentialTile = landTileMap.get(key);
                    if (potentialTile &&
                        potentialTile.type !== TILE_TYPES.MOUNTAIN_PEAK &&
                        potentialTile.type !== TILE_TYPES.STONE &&
                        // *** ADDED WATER CHECKS ***
                        potentialTile.type !== TILE_TYPES.DEEP_WATER &&
                        potentialTile.type !== TILE_TYPES.SHALLOW_WATER &&
                        // Ensure the potential tile's y is not significantly below water if it's near water
                        // (This check is more robust if potentialTile.y is always ground level)
                        // potentialTile.y > (TRANSPARENT_LAYER_Y - 0.1) && // Example: don't jump to something just below water surface
                        Math.abs(potentialTile.y - fox.currentTile.y) <= FOX_MAX_JUMP_HEIGHT_DIFFERENCE) {
                        possibleTargets.push(potentialTile);
                    }
                });

                if (possibleTargets.length > 0) {
                    fox.targetTile = possibleTargets[Math.floor(Math.random() * possibleTargets.length)];
                    // fox.targetTile.y is the top surface of the target hex tile.
                    fox.targetPosition.set(fox.targetTile.x, fox.targetTile.y + FOX_MODEL_GROUND_OFFSET, fox.targetTile.z);
                    fox.startPosition.copy(fox.model.position);
                    fox.startTileY = fox.currentTile.y; // Surface height of start tile
                    fox.targetTileY = fox.targetTile.y; // Surface height of target tile
                    fox.state = 'moving';
                    fox.movementProgress = 0;
                } else {
                    fox.idleTimer = Math.random() * (STUCK_FOX_IDLE_TIME_MAX - STUCK_FOX_IDLE_TIME_MIN) + STUCK_FOX_IDLE_TIME_MIN;
                    fox.state = 'idle';
                }
            }

            if (fox.state === 'moving' && fox.targetTile) {
                const direction = new THREE.Vector3().subVectors(fox.targetPosition, fox.model.position);
                // Y component of direction is now based on tile heights + offset, so keep it for vertical arc
                // direction.y = 0; // No longer zeroing out Y for distance calc, use it for the jump arc
                const distanceToTargetXZ = new THREE.Vector2(direction.x, direction.z).length();


                if (distanceToTargetXZ > 0.05) { // Check XZ distance for completion
                    const targetWorldAngle = Math.atan2(direction.z, direction.x); // For XZ movement
                    const rotTargetAngle = Math.atan2(-direction.z, direction.x); // For model rotation

                    let currentModelRotationY = fox.model.rotation.y;
                    while (rotTargetAngle - currentModelRotationY > Math.PI) currentModelRotationY += 2 * Math.PI;
                    while (rotTargetAngle - currentModelRotationY < -Math.PI) currentModelRotationY -= 2 * Math.PI;
                    const turnLerpFactor = Math.min(FOX_TURN_SPEED * deltaTime, 1);
                    fox.model.rotation.y = THREE.MathUtils.lerp(currentModelRotationY, rotTargetAngle, turnLerpFactor);

                    let angleDiff = Math.abs(rotTargetAngle - fox.model.rotation.y);
                    // Ensure angleDiff considers wrapping around PI
                    angleDiff = Math.min(angleDiff, 2 * Math.PI - angleDiff);


                    if (angleDiff < Math.PI / 2.5) { // Start moving if mostly facing target
                        const moveDistanceXZ = Math.min(FOX_SPEED * deltaTime, distanceToTargetXZ);
                        fox.model.position.x += Math.cos(targetWorldAngle) * moveDistanceXZ;
                        fox.model.position.z += Math.sin(targetWorldAngle) * moveDistanceXZ;

                        const currentPosXZ = new THREE.Vector2(fox.model.position.x, fox.model.position.z);
                        const startPosXZ = new THREE.Vector2(fox.startPosition.x, fox.startPosition.z);
                        const targetPosXZ_vec = new THREE.Vector2(fox.targetPosition.x, fox.targetPosition.z);

                        const distCoveredXZ = startPosXZ.distanceTo(currentPosXZ);
                        const totalDistForSegmentXZ = startPosXZ.distanceTo(targetPosXZ_vec);

                        fox.movementProgress = totalDistForSegmentXZ > 0.01 ? Math.min(distCoveredXZ / totalDistForSegmentXZ, 1.0) : (distanceToTargetXZ <= 0.05 ? 1.0 : 0);

                        // Y position calculation using the step interpolation for an arc
                        // startPosition.y and targetPosition.y already include FOX_MODEL_GROUND_OFFSET
                        const yProgressArc = stepInterpolationMidpoint(fox.movementProgress, 0.3); // Smoother arc
                        fox.model.position.y = THREE.MathUtils.lerp(fox.startPosition.y, fox.targetPosition.y, yProgressArc);


                        // Footprints are placed relative to the fox's current Y, minus its ground offset.
                        const foxFeetGroundLevelY = fox.model.position.y - FOX_MODEL_GROUND_OFFSET;

                        if (canLeaveFootprints && fox.footprintCooldown <= 0) {
                            const footprintY = foxFeetGroundLevelY + FOX_FOOTPRINT_Y_OFFSET;

                            const footprintForwardOffset = 0.03;
                            const footprintSideOffsetVal = 0.035;
                            let sideMultiplier = (fox.nextFootprintSide === 'left') ? 1 : -1;

                            const print = new THREE.Mesh(footprintGeometryRef.current, footprintMaterialRef.current.clone()); // Clone material for opacity fade

                            const localOffsetX = footprintSideOffsetVal * sideMultiplier;
                            const localOffsetZ = -footprintForwardOffset; // Footprints slightly behind center of model

                            // Transform local offset to world offset based on fox model's rotation
                            const worldOffsetX = localOffsetX * Math.cos(fox.model.rotation.y) - localOffsetZ * Math.sin(fox.model.rotation.y);
                            const worldOffsetZ = localOffsetX * Math.sin(fox.model.rotation.y) + localOffsetZ * Math.cos(fox.model.rotation.y);

                            print.position.x = fox.model.position.x + worldOffsetX;
                            print.position.y = footprintY;
                            print.position.z = fox.model.position.z + worldOffsetZ;

                            print.rotation.x = -Math.PI / 2; // Align plane with ground
                            print.rotation.z = fox.model.rotation.y - Math.PI / 2; // Align with fox's body direction
                            footprintsGroupRef.current.add(print);
                            activeFootprintsRef.current.push({ mesh: print, creationTime: elapsedTime });

                            fox.footprintCooldown = FOX_FOOTPRINT_INTERVAL_SECONDS;
                            fox.nextFootprintSide = (fox.nextFootprintSide === 'left') ? 'right' : 'left';
                        }
                    }
                } else { // XZ distance is small, snap to target
                    fox.model.position.copy(fox.targetPosition);
                    fox.currentTile = fox.targetTile;
                    fox.startTileY = fox.targetTile.y; // Update startY for next move
                    fox.targetTile = null;
                    fox.state = 'idle';
                    fox.idleTimer = Math.random() * (ACTUAL_FOX_IDLE_TIME_MAX - ACTUAL_FOX_IDLE_TIME_MIN) + ACTUAL_FOX_IDLE_TIME_MIN;
                    fox.movementProgress = 0;
                }
            }

            // Animation of fox parts
            const { legs, head, tail, headOriginalY, tailOriginalZRotation } = fox.model.userData;
            if (fox.state === 'moving') {
                if (legs) {
                    const legSwing = Math.sin(fox.animationTime * FOX_LEG_ANIM_SPEED_FACTOR) * FOX_MAX_LEG_SWING_X;
                    if (legs.frontLeft) legs.frontLeft.rotation.z = legSwing;
                    if (legs.backRight) legs.backRight.rotation.z = legSwing;
                    if (legs.frontRight) legs.frontRight.rotation.z = -legSwing;
                    if (legs.backLeft) legs.backLeft.rotation.z = -legSwing;
                }
                if (head && headOriginalY !== undefined) {
                    const headBob = Math.cos(fox.animationTime * FOX_HEAD_BOB_SPEED_FACTOR) * FOX_HEAD_BOB_AMOUNT;
                    head.position.y = headOriginalY + headBob; // headOriginalY is relative to fox model's origin
                    head.rotation.y = 0; // Head faces forward when moving
                }
                if (tail && tailOriginalZRotation !== undefined) {
                    const tailWag = Math.sin(fox.animationTime * FOX_TAIL_WAG_SPEED_FACTOR) * FOX_TAIL_WAG_ANGLE_Z;
                    tail.rotation.z = tailOriginalZRotation + tailWag;
                }
            } else { // Idle state animations
                if (legs) { // Legs to neutral position
                    if (legs.frontLeft) legs.frontLeft.rotation.z = 0;
                    if (legs.backRight) legs.backRight.rotation.z = 0;
                    if (legs.frontRight) legs.frontRight.rotation.z = 0;
                    if (legs.backLeft) legs.backLeft.rotation.z = 0;
                }
                if (head && headOriginalY !== undefined) {
                    head.position.y = headOriginalY; // Reset bob
                    const headTurn = Math.sin(elapsedTime * FOX_HEAD_IDLE_SPEED_FACTOR + fox.animationTime * 0.1) * FOX_HEAD_IDLE_TURN_Y_ANGLE;
                    head.rotation.y = headTurn; // Random head turns
                }
                if (tail && tailOriginalZRotation !== undefined) {
                    const tailSwish = Math.sin(elapsedTime * FOX_TAIL_IDLE_SPEED_FACTOR + fox.animationTime * 0.1) * FOX_TAIL_IDLE_SWISH_Z_ANGLE;
                    tail.rotation.z = tailOriginalZRotation + tailSwish; // Gentle tail swish
                }
            }
        });

        // Manage footprint lifetime and fading
        const newActiveFootprints = [];
        for (const fp of activeFootprintsRef.current) {
            const age = elapsedTime - fp.creationTime;
            if (age < FOX_FOOTPRINT_LIFETIME_SECONDS) {
                fp.mesh.material.opacity = FOX_FOOTPRINT_OPACITY * (1 - (age / FOX_FOOTPRINT_LIFETIME_SECONDS));
                newActiveFootprints.push(fp);
            } else {
                footprintsGroupRef.current.remove(fp.mesh);
                if (fp.mesh.material) fp.mesh.material.dispose(); // Dispose cloned material
                // Geometry is shared, don't dispose footprintGeometryRef.current here
            }
        }
        activeFootprintsRef.current = newActiveFootprints;

    }, [foxSystemData, landTileMap, gridColumns, gridRows, coreElements, season, snowAccumulationRatio]); // Added season/snow back for footprint logic

    // Expose only what's needed by useThreeScene
    if (foxSystemData && foxSystemData.isReady) {
        return {
            // No need to expose foxGroup from here if useThreeScene doesn't directly interact with it
            isReady: true,
            updateFoxes
        };
    }
    return null;
};

export default useFoxes;

## src\components\HexMap\hooks\useSunAndSky.js ##
// src/components/HexMap/hooks/useSunAndSky.js
import { useEffect, useRef, useState } from 'react'; // Removed useCallback
import * as THREE from 'three';
import {
    SEASONS, SHADOW_MAP_SIZE, WEATHER_TYPES,
    MAX_SUN_ELEVATION_SUMMER, MAX_SUN_ELEVATION_WINTER, SUN_AZIMUTH_SWING,
    MOON_LIGHT_INTENSITY, MOON_COLOR, MOON_SIZE_FACTOR,
    SUN_INTENSITY_CLOUDY_FACTOR, MOON_INTENSITY_CLOUDY_FACTOR
    // Removed SHADOW_FADE_DURATION, SHADOW_MAX_BLUR_RADIUS_FACTOR
} from '../constants';
import { calculateSunPosition, getSunLightColor, getMoonLightColor, getSkyAndFogColor } from '../utils/colorUtils';

const useSunAndSky = (coreElements, timeOfDay, season, weatherCondition, snowAccumulationRatio) => {
    const [celestialSystem, setCelestialSystem] = useState({
        sunLight: null, sunMesh: null, moonLight: null, moonMesh: null,
        originalSunShadowRadius: 1, originalMoonShadowRadius: 0.8, // Store original radius for sharpness
        isReady: false,
    });

    const initialSettingsAppliedRef = useRef(false);

    useEffect(() => {
        if (!coreElements || !coreElements.isReady || !coreElements.scene || !(coreElements.scene instanceof THREE.Scene) ||
            coreElements.worldMapWidth === undefined || coreElements.worldMapDepth === undefined) {
            if (celestialSystem.isReady) setCelestialSystem(prev => ({ ...prev, isReady: false }));
            return;
        }
        if (celestialSystem.isReady && initialSettingsAppliedRef.current) {
            return;
        }

        const { scene, worldMapWidth, worldMapDepth } = coreElements;
        console.log("useSunAndSky: Initializing celestial objects (simplified shadows)...");

        const originalSunSettings = { bias: -0.0000, normalBias: 0.02, mapSize: SHADOW_MAP_SIZE, radius: 1 };
        const originalMoonSettings = { bias: -0.000, normalBias: 0.03, mapSize: SHADOW_MAP_SIZE / 2, radius: 0.8 };

        const sunLight = new THREE.DirectionalLight(0xFFFDD0, 2.8);
        sunLight.castShadow = false; // Initially off
        sunLight.shadow.mapSize.width = originalSunSettings.mapSize;
        sunLight.shadow.mapSize.height = originalSunSettings.mapSize;
        const shadowCamSize = Math.max(worldMapWidth, worldMapDepth) * 0.9;
        sunLight.shadow.camera.left = -shadowCamSize; sunLight.shadow.camera.right = shadowCamSize;
        sunLight.shadow.camera.top = shadowCamSize; sunLight.shadow.camera.bottom = -shadowCamSize;
        sunLight.shadow.camera.near = 0.5;
        sunLight.shadow.camera.far = Math.max(worldMapWidth, worldMapDepth) * 3;
        sunLight.shadow.bias = originalSunSettings.bias;
        sunLight.shadow.normalBias = originalSunSettings.normalBias;
        sunLight.shadow.radius = originalSunSettings.radius; // Set to default sharp radius
        scene.add(sunLight); scene.add(sunLight.target); sunLight.target.position.set(0, 0, 0);

        const sunMeshGeometry = new THREE.SphereGeometry(Math.max(worldMapWidth, worldMapDepth) * MOON_SIZE_FACTOR, 32, 32);
        const sunMeshMaterial = new THREE.MeshBasicMaterial({ fog: false });
        const sunMesh = new THREE.Mesh(sunMeshGeometry, sunMeshMaterial);
        sunMesh.name = "SunMesh"; scene.add(sunMesh);

        const moonLight = new THREE.DirectionalLight(MOON_COLOR, MOON_LIGHT_INTENSITY);
        moonLight.castShadow = false; // Initially off
        moonLight.shadow.mapSize.width = originalMoonSettings.mapSize;
        moonLight.shadow.mapSize.height = originalMoonSettings.mapSize;
        moonLight.shadow.camera.left = -shadowCamSize; moonLight.shadow.camera.right = shadowCamSize;
        moonLight.shadow.camera.top = shadowCamSize; moonLight.shadow.camera.bottom = -shadowCamSize;
        moonLight.shadow.camera.near = 0.5; moonLight.shadow.camera.far = Math.max(worldMapWidth, worldMapDepth) * 3;
        moonLight.shadow.bias = originalMoonSettings.bias;
        moonLight.shadow.normalBias = originalMoonSettings.normalBias;
        moonLight.shadow.radius = originalMoonSettings.radius; // Set to default sharp radius
        moonLight.visible = false; scene.add(moonLight); scene.add(moonLight.target); moonLight.target.position.set(0, 0, 0);

        const moonMeshGeometry = new THREE.SphereGeometry(Math.max(worldMapWidth, worldMapDepth) * MOON_SIZE_FACTOR, 32, 32);
        const moonMeshMaterial = new THREE.MeshBasicMaterial({ color: MOON_COLOR, fog: false });
        const moonMesh = new THREE.Mesh(moonMeshGeometry, moonMeshMaterial);
        moonMesh.name = "MoonMesh"; moonMesh.visible = false; scene.add(moonMesh);

        setCelestialSystem(prev => ({
            ...prev,
            sunLight, sunMesh, moonLight, moonMesh,
            originalSunShadowRadius: originalSunSettings.radius,
            originalMoonShadowRadius: originalMoonSettings.radius,
            isReady: true,
        }));
        initialSettingsAppliedRef.current = true;

        return () => {
            initialSettingsAppliedRef.current = false;
            if (sunLight?.parent) scene.remove(sunLight);
            if (sunLight?.target?.parent) scene.remove(sunLight.target);
            if (sunLight?.shadow?.map) sunLight.shadow.map.dispose();
            if (sunMesh?.parent) scene.remove(sunMesh);
            if (sunMesh?.geometry) sunMesh.geometry.dispose();
            if (sunMesh?.material) sunMesh.material.dispose();
            if (moonLight?.parent) scene.remove(moonLight);
            if (moonLight?.target?.parent) scene.remove(moonLight.target);
            if (moonLight?.shadow?.map) moonLight.shadow.map.dispose();
            if (moonMesh?.parent) scene.remove(moonMesh);
            if (moonMesh?.geometry) moonMesh.geometry.dispose();
            if (moonMesh?.material) moonMesh.material.dispose();
            setCelestialSystem(prev => ({ ...prev, isReady: false, sunLight: null, moonLight: null }));
        };
    }, [coreElements]);

    useEffect(() => {
        if (!celestialSystem.isReady || !coreElements?.isReady || !coreElements.scene ||
            !coreElements.ambientLight || snowAccumulationRatio === undefined) {
            return;
        }

        const { scene, worldMapWidth, worldMapDepth, ambientLight } = coreElements;
        const { sunLight, sunMesh, moonLight, moonMesh,
            originalSunShadowRadius, originalMoonShadowRadius
        } = celestialSystem;

        const isActuallySnowing = season === SEASONS.WINTER && weatherCondition === WEATHER_TYPES.SNOW;
        const isCloudyWeather = weatherCondition === WEATHER_TYPES.CLOUDY;
        const isRainyWeather = weatherCondition === WEATHER_TYPES.RAINY;

        let overcastLerpFactor = 0;
        if (isCloudyWeather || isRainyWeather) {
            overcastLerpFactor = 1.0;
        }
        if (isActuallySnowing) {
            overcastLerpFactor = snowAccumulationRatio;
        } else if (snowAccumulationRatio > 0 && (isCloudyWeather || isRainyWeather)) {
            overcastLerpFactor = 1.0;
        } else if (snowAccumulationRatio > 0) {
            overcastLerpFactor = snowAccumulationRatio;
        }

        const baseAmbient = 0.4;
        const overcastAmbient = 0.7;
        const snowTargetAmbient = 0.8;
        let currentAmbient = baseAmbient;
        if (isCloudyWeather || isRainyWeather) currentAmbient = overcastAmbient;
        currentAmbient = THREE.MathUtils.lerp(currentAmbient, snowTargetAmbient, isActuallySnowing ? snowAccumulationRatio : (season === SEASONS.WINTER && weatherCondition !== WEATHER_TYPES.SNOW ? snowAccumulationRatio : 0));
        ambientLight.intensity = currentAmbient;

        const { elevation: sunElevation, azimuth: sunAzimuth } = calculateSunPosition(
            timeOfDay, season, MAX_SUN_ELEVATION_SUMMER, MAX_SUN_ELEVATION_WINTER, SUN_AZIMUTH_SWING
        );
        sunLight.position.set( /* ... */); // Position calculation remains the same
        const sunAzimuthRad = THREE.MathUtils.degToRad(sunAzimuth);
        const sunElevationRad = THREE.MathUtils.degToRad(sunElevation);
        const celestialDistance = Math.max(worldMapWidth, worldMapDepth) * 1.5;
        sunLight.position.set(
            celestialDistance * Math.cos(sunElevationRad) * Math.cos(sunAzimuthRad),
            celestialDistance * Math.sin(sunElevationRad),
            celestialDistance * Math.cos(sunElevationRad) * Math.sin(sunAzimuthRad)
        );

        sunLight.color.set(getSunLightColor(sunElevation));
        const sunBaseIntensityVal = sunElevation > -5 ? 2.8 : 0.05;
        let currentSunIntensityReductionFactor = isCloudyWeather || isRainyWeather || isActuallySnowing ? SUN_INTENSITY_CLOUDY_FACTOR : 1.0;
        if (isActuallySnowing) currentSunIntensityReductionFactor = SUN_INTENSITY_CLOUDY_FACTOR * 1.2; // Snow still dims, but maybe slightly less than pure clouds

        sunLight.intensity = THREE.MathUtils.lerp(sunBaseIntensityVal, sunBaseIntensityVal * currentSunIntensityReductionFactor, overcastLerpFactor);
        sunLight.visible = sunElevation > -8;

        if (sunMesh?.material) {
            sunMesh.position.copy(sunLight.position).normalize().multiplyScalar(Math.max(worldMapWidth, worldMapDepth) * 2.5);
            sunMesh.material.color.copy(sunLight.color);
            sunMesh.visible = sunElevation > -2 && !(isCloudyWeather || isRainyWeather || isActuallySnowing);
        }

        const moonTime = (timeOfDay + 12) % 24;
        const { elevation: moonElevation, azimuth: moonAzimuth } = calculateSunPosition(moonTime, season, 65, 65, 100);
        moonLight.position.set( /* ... */); // Position calculation remains the same
        const moonAzimuthRad = THREE.MathUtils.degToRad(moonAzimuth);
        const moonElevationRad = THREE.MathUtils.degToRad(moonElevation);
        moonLight.position.set(
            celestialDistance * Math.cos(moonElevationRad) * Math.cos(moonAzimuthRad),
            celestialDistance * Math.sin(moonElevationRad),
            celestialDistance * Math.cos(moonElevationRad) * Math.sin(moonAzimuthRad)
        );

        moonLight.color.set(getMoonLightColor(moonElevation));
        const moonBaseIntensityVal = MOON_LIGHT_INTENSITY * Math.max(0, Math.sin(THREE.MathUtils.degToRad(moonElevation)));
        let currentMoonIntensityReductionFactor = isCloudyWeather || isRainyWeather || isActuallySnowing ? MOON_INTENSITY_CLOUDY_FACTOR : 1.0;
        if (isActuallySnowing) currentMoonIntensityReductionFactor = MOON_INTENSITY_CLOUDY_FACTOR * 1.1;

        moonLight.intensity = THREE.MathUtils.lerp(moonBaseIntensityVal, moonBaseIntensityVal * currentMoonIntensityReductionFactor, overcastLerpFactor);
        moonLight.visible = moonElevation > -5 && sunElevation < 5 && moonLight.intensity > 0.01;

        if (moonMesh?.material) {
            moonMesh.position.copy(moonLight.position).normalize().multiplyScalar(Math.max(worldMapWidth, worldMapDepth) * 2.0);
            moonMesh.material.color.set(MOON_COLOR);
            moonMesh.visible = moonElevation > -2 && !(isCloudyWeather || isRainyWeather || isActuallySnowing);
        }

        // Simplified Shadow Logic:
        // Shadows are ON if light is visible and reasonably bright.
        // During snow, shadows might persist if light is strong enough through the overcast.
        const sunShadowsActive = sunLight.visible && sunLight.intensity > (sunBaseIntensityVal * SUN_INTENSITY_CLOUDY_FACTOR * 0.2); // Threshold for sun shadow
        if (sunLight.castShadow !== sunShadowsActive) {
            sunLight.castShadow = sunShadowsActive;
        }
        if (sunShadowsActive && sunLight.shadow.radius !== originalSunShadowRadius) {
            sunLight.shadow.radius = originalSunShadowRadius; // Ensure solid shadow
        }

        const moonShadowsActive = moonLight.visible && moonLight.intensity > (moonBaseIntensityVal * MOON_INTENSITY_CLOUDY_FACTOR * 0.15); // Threshold for moon shadow
        if (moonLight.castShadow !== moonShadowsActive) {
            moonLight.castShadow = moonShadowsActive;
        }
        if (moonShadowsActive && moonLight.shadow.radius !== originalMoonShadowRadius) {
            moonLight.shadow.radius = originalMoonShadowRadius; // Ensure solid shadow
        }


        const skyAndFogColor = getSkyAndFogColor(sunElevation, moonElevation, sunLight.color, weatherCondition, season, snowAccumulationRatio);
        if (!(scene.background instanceof THREE.CubeTexture)) {
            if (!scene.background || !(scene.background instanceof THREE.Color)) scene.background = new THREE.Color();
            scene.background.set(skyAndFogColor);
        }
        if (scene.fog) {
            scene.fog.color.set(skyAndFogColor);
            const defaultFogNear = 50; const defaultFogFar = 300;
            const rainyFogNear = 30; const rainyFogFar = 200;
            const snowyFogNear = 20; const snowyFogFar = 150;
            let currentFogNear = defaultFogNear; let currentFogFar = defaultFogFar;

            if (isActuallySnowing) {
                const baseNear = (isRainyWeather && !isActuallySnowing) ? rainyFogNear : defaultFogNear;
                const baseFar = (isRainyWeather && !isActuallySnowing) ? rainyFogFar : defaultFogFar;
                currentFogNear = THREE.MathUtils.lerp(baseNear, snowyFogNear, snowAccumulationRatio);
                currentFogFar = THREE.MathUtils.lerp(baseFar, snowyFogFar, snowAccumulationRatio);
            } else if (isRainyWeather) {
                currentFogNear = rainyFogNear; currentFogFar = rainyFogFar;
                if (snowAccumulationRatio > 0) { // Melting from snow to rain
                    currentFogNear = THREE.MathUtils.lerp(snowyFogNear, rainyFogNear, 1.0 - snowAccumulationRatio);
                    currentFogFar = THREE.MathUtils.lerp(snowyFogFar, rainyFogFar, 1.0 - snowAccumulationRatio);
                }
            } else if (snowAccumulationRatio > 0) { // Melting from snow to clear/cloudy
                currentFogNear = THREE.MathUtils.lerp(snowyFogNear, defaultFogNear, 1.0 - snowAccumulationRatio);
                currentFogFar = THREE.MathUtils.lerp(snowyFogFar, defaultFogFar, 1.0 - snowAccumulationRatio);
            }
            scene.fog.near = currentFogNear; scene.fog.far = currentFogFar;
        }

    }, [
        celestialSystem.isReady, coreElements, timeOfDay, season,
        weatherCondition, snowAccumulationRatio,
        celestialSystem.originalSunShadowRadius, celestialSystem.originalMoonShadowRadius
    ]);

    // updateTransitions function is removed as it's no longer needed for radius animation.
    // The main useEffect now handles direct toggling of castShadow.

    return celestialSystem.isReady ? { ...celestialSystem } : null; // Removed updateTransitions from return
};

export default useSunAndSky;

## src\components\HexMap\hooks\useThreeCore.js ##
// src/components/HexMap/hooks/useThreeCore.js
import { useEffect, useRef, useState } from 'react';
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
import { HEX_SIZE, TRANSPARENT_LAYER_Y, GRID_COLUMNS, GRID_ROWS } from '../constants';

const POINTY_HEX_TRUE_WIDTH_CALC = HEX_SIZE * Math.sqrt(3);
const POINTY_HEX_TRUE_HEIGHT_CALC = HEX_SIZE * 2;
const POINTY_HEX_VERT_SPACING_CALC = POINTY_HEX_TRUE_HEIGHT_CALC * 0.75;

const useThreeCore = (mountRef, gridColumns, gridRows) => {
    const [coreState, setCoreState] = useState(null);
    const sceneIdRef = useRef(null); // To track scene instance

    useEffect(() => {
        const currentMount = mountRef.current;
        if (!currentMount) {
            if (coreState) {
                console.log("useThreeCore: Mount ref cleared, clearing core state.");
                setCoreState(null);
            }
            return;
        }

        console.log("useThreeCore: Initializing...");

        const scene = new THREE.Scene();
        if (sceneIdRef.current !== scene.uuid) {
            console.log(`useThreeCore: New Scene ID: ${scene.uuid} (Previous: ${sceneIdRef.current})`);
            sceneIdRef.current = scene.uuid;
        } else {
            console.log(`useThreeCore: Re-running useEffect but Scene ID is the same: ${scene.uuid}`);
        }
        scene.fog = new THREE.Fog(0x111122, 50, 300);

        const worldMapWidth = gridColumns * POINTY_HEX_TRUE_WIDTH_CALC;
        const worldMapDepth = gridRows * POINTY_HEX_VERT_SPACING_CALC;

        const camera = new THREE.PerspectiveCamera(60, currentMount.clientWidth / currentMount.clientHeight, 0.1, 1500);
        camera.position.set(worldMapWidth * 0.4, Math.max(worldMapWidth, worldMapDepth) * 0.5, worldMapDepth * 0.8);
        camera.lookAt(0, TRANSPARENT_LAYER_Y, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(currentMount.clientWidth, currentMount.clientHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.outputColorSpace = THREE.SRGBColorSpace; // Corrected from outputEncoding

        // Clear previous renderer DOM element if any
        while (currentMount.firstChild) {
            currentMount.removeChild(currentMount.firstChild);
        }
        currentMount.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.target.set(0, TRANSPARENT_LAYER_Y, 0);
        controls.maxDistance = Math.max(worldMapWidth, worldMapDepth) * 1.5;

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);

        console.log("useThreeCore: Core initialized, setting state with scene:", scene.uuid);
        setCoreState({
            scene, camera, renderer, controls, ambientLight,
            worldMapWidth, worldMapDepth,
            isReady: true,
        });

        const handleResize = () => {
            // Use the camera and renderer instances from this effect's closure
            // to avoid issues if coreState hasn't updated yet.
            if (camera && renderer && currentMount) {
                camera.aspect = currentMount.clientWidth / currentMount.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(currentMount.clientWidth, currentMount.clientHeight);
            }
        };
        window.addEventListener('resize', handleResize);

        return () => {
            console.log("useThreeCore: Cleaning up scene:", scene.uuid);
            window.removeEventListener('resize', handleResize);

            if (controls) controls.dispose();
            // scene.remove(ambientLight); // Ambient light is part of this scene, will be disposed with it
            if (renderer) {
                if (currentMount && renderer.domElement && currentMount.contains(renderer.domElement)) {
                    try { currentMount.removeChild(renderer.domElement); } catch (e) {/*ignore*/ }
                }
                renderer.dispose();
            }
            // scene.dispose(); // Dispose scene resources if necessary, though Three.js often handles children.
            // Forcing a clear of coreState might be too aggressive if other hooks depend on its stability.
            // setCoreState(null); // Let's see if not nulling it out helps, and rely on new instance replacing.
            sceneIdRef.current = null; // Reset for next potential init
        };
    }, [mountRef, gridColumns, gridRows]); // Dependencies

    return coreState;
};

export default useThreeCore;

## src\components\HexMap\hooks\useThreeScene.js ##
// src/components/HexMap/hooks/useThreeScene.js
import React, { useEffect, useRef, useState, useCallback } from 'react';
import * as THREE from 'three';
import useThreeCore from './useThreeCore';
import useSunAndSky from './useSunAndSky';
import useWorldGeometry from './useWorldGeometry';
import useWater from './useWater';
import useFoxes from './useFoxes';
import useWeatherEffects from './useWeatherEffects';
import useBuildings from '../buildings/useBuildings';
import { BUILDING_TYPES as AllBuildingTypes } from '../buildings/BuildingTypes'; // Renamed for clarity
import { TILE_TYPES, SEASONS, WEATHER_TYPES, SNOW_ACCUMULATION_SECONDS, SNOW_MELT_SECONDS, BUILDABLE_TILE_TYPES } from '../constants';


const getAdjacentTileKeys = (c, r) => {
    const isOddRow = r % 2 === 1;
    return [
        { dc: 1, dr: 0 }, { dc: -1, dr: 0 },
        { dc: isOddRow ? 1 : 0, dr: 1 }, { dc: isOddRow ? 0 : -1, dr: 1 },
        { dc: isOddRow ? 1 : 0, dr: -1 }, { dc: isOddRow ? 0 : -1, dr: -1 }
    ].map(n => `${c + n.dc},${r + n.dr}`);
};


const useThreeScene = (
    mountRef,
    islandHeightData,
    gridColumns,
    gridRows,
    timeOfDay,
    season,
    weatherCondition
) => {
    const [isFullyInitialized, setIsFullyInitialized] = useState(false);
    const animationFrameIdRef = useRef(null);
    const clockRef = useRef(null);
    const systemsRef = useRef({});

    const [snowAccumulationRatio, setSnowAccumulationRatio] = useState(0);
    const targetSnowAccumulationRef = useRef(0);

    const [selectedTileForBuilding, setSelectedTileForBuilding] = useState(null);
    const [isBuildingPaletteOpen, setIsBuildingPaletteOpen] = useState(false);
    // Store more info about existing building: type and rotation
    const [existingBuildingOnSelectedTile, setExistingBuildingOnSelectedTile] = useState(null);

    systemsRef.current.core = useThreeCore(mountRef, gridColumns, gridRows);

    systemsRef.current.sunSky = useSunAndSky(
        systemsRef.current.core, timeOfDay, season, weatherCondition, snowAccumulationRatio
    );

    systemsRef.current.worldGeometry = useWorldGeometry(
        systemsRef.current.core,
        islandHeightData, weatherCondition, season, snowAccumulationRatio,
        (c, r) => {
            const buildings = systemsRef.current.buildings;
            if (buildings && typeof buildings.getBuildingOnTile === 'function') {
                return buildings.getBuildingOnTile(c, r); // This now returns { type, model, isLit, rotationY }
            }
            return undefined;
        }
    );

    systemsRef.current.buildings = useBuildings(
        systemsRef.current.core,
        snowAccumulationRatio,
        timeOfDay,
        systemsRef.current.worldGeometry?.landTileMap,
        gridColumns,
        gridRows
    );

    systemsRef.current.water = useWater(systemsRef.current.core);

    systemsRef.current.foxes = useFoxes(
        systemsRef.current.core,
        systemsRef.current.worldGeometry?.landTiles,
        systemsRef.current.worldGeometry?.landTileMap,
        gridColumns, gridRows, season, snowAccumulationRatio
    );

    systemsRef.current.weatherEffects = useWeatherEffects(
        systemsRef.current.core, weatherCondition, season
    );

    useEffect(() => {
        if (systemsRef.current.core && systemsRef.current.sunSky) {
            if (!systemsRef.current.core.sunSky) {
                systemsRef.current.core.sunSky = systemsRef.current.sunSky;
            }
        }
    }, [systemsRef.current.core, systemsRef.current.sunSky]);


    useEffect(() => {
        const isSnowingInWinter = season === SEASONS.WINTER && weatherCondition === WEATHER_TYPES.SNOW;
        targetSnowAccumulationRef.current = isSnowingInWinter ? 1 : 0;
    }, [season, weatherCondition]);


    const raycasterRef = useRef(new THREE.Raycaster());
    const mousePositionRef = useRef(new THREE.Vector2());

    const handleCanvasClick = useCallback((event) => {
        const { core, worldGeometry, buildings } = systemsRef.current;
        if (!core?.isReady || !worldGeometry?.isReady || !mountRef.current || !buildings?.isReady) return;

        const { camera } = core;
        const { hexMeshesForRaycasting, landTileMap } = worldGeometry;

        if (!hexMeshesForRaycasting || hexMeshesForRaycasting.length === 0 || !landTileMap) return;

        const rect = mountRef.current.getBoundingClientRect();
        mousePositionRef.current.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mousePositionRef.current.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

        raycasterRef.current.setFromCamera(mousePositionRef.current, camera);
        const intersects = raycasterRef.current.intersectObjects(hexMeshesForRaycasting, false);

        if (intersects.length > 0) {
            const firstIntersect = intersects[0].object;
            if (firstIntersect.userData?.isHexTile) {
                const tileData = firstIntersect.userData.tileData;

                if (BUILDABLE_TILE_TYPES.includes(tileData.type)) {
                    setSelectedTileForBuilding(tileData);
                    const existingBuildingData = buildings.getBuildingOnTile(tileData.c, tileData.r);
                    // Store type and rotation for the palette
                    setExistingBuildingOnSelectedTile(
                        existingBuildingData ? { type: existingBuildingData.type, rotationY: existingBuildingData.rotationY } : null
                    );
                    setIsBuildingPaletteOpen(true);
                } else {
                    setIsBuildingPaletteOpen(false);
                    setSelectedTileForBuilding(null);
                    setExistingBuildingOnSelectedTile(null);
                }
            }
        } else {
            setIsBuildingPaletteOpen(false);
            setSelectedTileForBuilding(null);
            setExistingBuildingOnSelectedTile(null);
        }
    }, []);

    useEffect(() => {
        const currentMount = mountRef.current;
        if (currentMount) {
            currentMount.addEventListener('click', handleCanvasClick);
        }
        return () => {
            if (currentMount) {
                currentMount.removeEventListener('click', handleCanvasClick);
            }
        };
    }, [handleCanvasClick]);

    useEffect(() => {
        const { core, sunSky, worldGeometry, water, buildings, foxes, weatherEffects } = systemsRef.current;
        const coreRdy = core?.isReady;
        const sunSkyRdy = sunSky?.isReady;
        const worldRdyCheck = worldGeometry?.isReady && worldGeometry?.landTileMap && worldGeometry?.hexMeshesForRaycasting;
        const waterRdy = water?.isReady;
        const buildingsRdy = buildings?.isReady &&
            typeof buildings?.getBuildingOnTile === 'function' &&
            typeof buildings?.addBuilding === 'function' &&
            typeof buildings?.updateBuilding === 'function'; // Check for new function

        const baseSystemsRdy = !!(coreRdy && sunSkyRdy && worldRdyCheck && waterRdy && buildingsRdy);
        const foxesActuallyRdy = !foxes || foxes.isReady;
        const weatherEffectsActuallyRdy = !weatherEffects || weatherEffects.isReady;
        const allSystemsGo = baseSystemsRdy && foxesActuallyRdy && weatherEffectsActuallyRdy;

        if (allSystemsGo !== isFullyInitialized) {
            if (allSystemsGo) console.log("useThreeScene: All systems GO! Fully initialized.");
            else console.warn("useThreeScene: Waiting for systems...", { coreRdy, sunSkyRdy, worldRdy: worldRdyCheck, waterRdy, buildingsRdy, foxesActuallyRdy, weatherEffectsActuallyRdy });
            setIsFullyInitialized(allSystemsGo);
        }
    }, [isFullyInitialized, systemsRef.current.core, systemsRef.current.sunSky, systemsRef.current.worldGeometry, systemsRef.current.water, systemsRef.current.buildings, systemsRef.current.foxes, systemsRef.current.weatherEffects]);

    useEffect(() => {
        if (!isFullyInitialized || !mountRef.current) {
            if (animationFrameIdRef.current) {
                cancelAnimationFrame(animationFrameIdRef.current);
                animationFrameIdRef.current = null;
            }
            return;
        }
        if (animationFrameIdRef.current) return;

        console.log("useThreeScene: Starting Animation Loop.");
        clockRef.current = new THREE.Clock(true);

        const animate = () => {
            animationFrameIdRef.current = requestAnimationFrame(animate);
            const { core, worldGeometry, water, buildings, foxes, weatherEffects } = systemsRef.current;
            if (!core?.isReady || !isFullyInitialized) return;

            const deltaTime = clockRef.current.getDelta();
            const elapsedTime = clockRef.current.getElapsedTime();

            setSnowAccumulationRatio(prevRatio => {
                let newRatio = prevRatio;
                const target = targetSnowAccumulationRef.current;
                if (newRatio < target) newRatio += deltaTime / SNOW_ACCUMULATION_SECONDS;
                else if (newRatio > target) newRatio -= deltaTime / SNOW_MELT_SECONDS;
                return Math.max(0, Math.min(1, newRatio));
            });

            if (water?.isReady && water.updateAnimation) water.updateAnimation(deltaTime);
            if (worldGeometry?.isReady && worldGeometry.updateAnimations) worldGeometry.updateAnimations(elapsedTime);
            if (buildings?.isReady && buildings.updateBuildingAnimations) buildings.updateBuildingAnimations(elapsedTime);
            if (foxes?.isReady && foxes.updateFoxes) foxes.updateFoxes(deltaTime, elapsedTime);
            if (weatherEffects?.isReady) {
                if (weatherEffects.updateRain) weatherEffects.updateRain(deltaTime);
                if (weatherEffects.updateSnow) weatherEffects.updateSnow(deltaTime);
            }
            if (core.controls) core.controls.update();
            if (core.renderer && core.scene && core.camera) {
                core.renderer.render(core.scene, core.camera);
            }
        };
        animate();
        return () => {
            console.log("useThreeScene: Cleaning up Animation Loop.");
            if (animationFrameIdRef.current) cancelAnimationFrame(animationFrameIdRef.current);
            animationFrameIdRef.current = null;
            if (clockRef.current) clockRef.current.stop();
        };
    }, [isFullyInitialized, mountRef]);


    const handleBuildRequest = useCallback((tile, buildingType) => {
        const { buildings, worldGeometry } = systemsRef.current;
        if (!buildings?.addBuilding || !worldGeometry?.landTileMap) {
            setIsBuildingPaletteOpen(false);
            setSelectedTileForBuilding(null);
            console.error("Cannot build: Building system or world geometry not ready.");
            return;
        }
        if (buildingType === AllBuildingTypes.HARBOUR) {
            let hasWaterNeighbor = false;
            const adjacentKeys = getAdjacentTileKeys(tile.c, tile.r);
            for (const key of adjacentKeys) {
                const neighborTile = worldGeometry.landTileMap.get(key);
                if (neighborTile && (neighborTile.type === TILE_TYPES.DEEP_WATER || neighborTile.type === TILE_TYPES.SHALLOW_WATER)) {
                    hasWaterNeighbor = true;
                    break;
                }
            }
            if (!hasWaterNeighbor) {
                alert("Harbours must be built on a coastal land tile next to water!");
                return;
            }
        }
        buildings.addBuilding(tile, buildingType);
        // After building, if it was a new build, the palette might close or update.
        // For now, close it. If replacing, the new rotation will be default.
        setIsBuildingPaletteOpen(false);
        setSelectedTileForBuilding(null);
        setExistingBuildingOnSelectedTile(null);
    }, []);

    const handleUpdateBuildingRequest = useCallback((tile, updates) => {
        const { buildings } = systemsRef.current;
        if (!buildings?.updateBuilding) {
            console.error("Cannot update building: Building system not ready.");
            return;
        }
        buildings.updateBuilding(tile, updates);
        // Optionally re-fetch building data to update palette if it stays open
        const updatedBuildingData = buildings.getBuildingOnTile(tile.c, tile.r);
        setExistingBuildingOnSelectedTile(
            updatedBuildingData ? { type: updatedBuildingData.type, rotationY: updatedBuildingData.rotationY } : null
        );
    }, []);


    const handleCancelBuild = useCallback(() => {
        setIsBuildingPaletteOpen(false);
        setSelectedTileForBuilding(null);
        setExistingBuildingOnSelectedTile(null);
    }, []);

    return {
        isBuildingPaletteOpen,
        selectedTileForBuilding,
        existingBuildingOnSelectedTile, // This now contains { type, rotationY }
        onBuild: handleBuildRequest,
        onCancel: handleCancelBuild,
        onUpdateBuilding: handleUpdateBuildingRequest, // New handler for updates
    };
};

export default useThreeScene;

## src\components\HexMap\hooks\useWater.js ##
// src/components/HexMap/hooks/useWater.js
import { useEffect, useRef, useState, useCallback } from 'react';
import * as THREE from 'three';
import {
    TRANSPARENT_LAYER_Y, TRANSPARENT_LAYER_OPACITY, TRANSPARENT_LAYER_COLOR,
    MAX_WAVE_SPEED_COMPONENT, WAVE_DIRECTION_CHANGE_INTERVAL_MIN,
    WAVE_DIRECTION_CHANGE_INTERVAL_MAX, WAVE_SPEED_LERP_FACTOR,
    SKYBOX_IMAGE_BASE_PATH, SKYBOX_IMAGE_NAMES, WATER_NORMAL_MAP_URL
} from '../constants';

const useWater = (coreElements) => {
    const [waterState, setWaterState] = useState(null);
    const waveAnimParamsRef = useRef(null);

    useEffect(() => {
        if (!coreElements || !coreElements.isReady || !coreElements.scene || !(coreElements.scene instanceof THREE.Scene) ||
            coreElements.worldMapWidth === undefined || coreElements.worldMapDepth === undefined) {
            if (waterState) setWaterState(null);
            return;
        }

        const { scene, worldMapWidth, worldMapDepth } = coreElements;
        console.log("useWater: Initializing...");

        const textureLoader = new THREE.TextureLoader();
        const cubeTextureLoader = new THREE.CubeTextureLoader();

        const waterMaterial = new THREE.MeshStandardMaterial({
            color: TRANSPARENT_LAYER_COLOR,
            opacity: TRANSPARENT_LAYER_OPACITY,
            transparent: true,
            side: THREE.DoubleSide,
            roughness: 0.1,
            metalness: 0.2,
            normalScale: new THREE.Vector2(0.2, 0.2),
            envMapIntensity: 0.7,
            depthWrite: false,
        });

        const environmentMap = cubeTextureLoader.load(
            SKYBOX_IMAGE_NAMES.map(name => `${SKYBOX_IMAGE_BASE_PATH}${name}`),
            (texture) => {
                waterMaterial.envMap = texture;
                waterMaterial.needsUpdate = true;
                console.log("useWater: Skybox env map loaded for water reflections.");
            },
            undefined,
            (err) => console.error("useWater: Error loading env map for water:", err)
        );

        const waterNormalMap = textureLoader.load(WATER_NORMAL_MAP_URL,
            (texture) => {
                texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                waterMaterial.normalMap = texture;
                waterMaterial.needsUpdate = true;
                console.log('useWater: Water normal map loaded.');
            },
            undefined,
            (err) => console.error('useWater: Error loading water normal map:', err)
        );

        const waterGeometry = new THREE.PlaneGeometry(worldMapWidth * 1.05, worldMapDepth * 1.05, 10, 10);
        const waterMesh = new THREE.Mesh(waterGeometry, waterMaterial);
        waterMesh.rotation.x = -Math.PI / 2;
        waterMesh.position.y = TRANSPARENT_LAYER_Y - 0.05;
        waterMesh.receiveShadow = true;
        waterMesh.renderOrder = 1;
        scene.add(waterMesh);

        waveAnimParamsRef.current = {
            currentSpeedX: (Math.random() - 0.5) * MAX_WAVE_SPEED_COMPONENT * 0.5,
            currentSpeedY: (Math.random() - 0.5) * MAX_WAVE_SPEED_COMPONENT * 0.5,
            targetSpeedX: (Math.random() - 0.5) * MAX_WAVE_SPEED_COMPONENT,
            targetSpeedY: (Math.random() - 0.5) * MAX_WAVE_SPEED_COMPONENT,
            timeToNextDirectionChange: Math.random() * (WAVE_DIRECTION_CHANGE_INTERVAL_MAX - WAVE_DIRECTION_CHANGE_INTERVAL_MIN) + WAVE_DIRECTION_CHANGE_INTERVAL_MIN,
        };

        console.log("useWater: Water system created, setting state.");
        setWaterState({
            waterMesh,
            waterMaterial,
            waterNormalMap,
            environmentMap,
            isReady: true
        });

        return () => {
            console.log("useWater: Cleaning up...");
            if (waterMesh && scene && waterMesh.parent === scene) scene.remove(waterMesh);
            if (waterGeometry) waterGeometry.dispose();
            if (waterMaterial) waterMaterial.dispose();
            if (waterNormalMap) waterNormalMap.dispose();
            if (environmentMap) environmentMap.dispose();

            waveAnimParamsRef.current = null;
            setWaterState(null);
        };
    }, [coreElements]);

    const updateAnimation = useCallback((deltaTime) => {
        if (!waterState || !waterState.isReady || !waveAnimParamsRef.current || !waterState.waterMaterial) return;

        const { waterMaterial } = waterState;
        const params = waveAnimParamsRef.current;

        if (waterMaterial.normalMap && waterMaterial.normalMap.image) {
            params.timeToNextDirectionChange -= deltaTime;
            if (params.timeToNextDirectionChange <= 0) {
                params.targetSpeedX = (Math.random() - 0.5) * MAX_WAVE_SPEED_COMPONENT * 2;
                params.targetSpeedY = (Math.random() - 0.5) * MAX_WAVE_SPEED_COMPONENT * 2;
                params.timeToNextDirectionChange = Math.random() * (WAVE_DIRECTION_CHANGE_INTERVAL_MAX - WAVE_DIRECTION_CHANGE_INTERVAL_MIN) + WAVE_DIRECTION_CHANGE_INTERVAL_MIN;
            }
            params.currentSpeedX = THREE.MathUtils.lerp(params.currentSpeedX, params.targetSpeedX, WAVE_SPEED_LERP_FACTOR);
            params.currentSpeedY = THREE.MathUtils.lerp(params.currentSpeedY, params.targetSpeedY, WAVE_SPEED_LERP_FACTOR);
            waterMaterial.normalMap.offset.x += params.currentSpeedX * deltaTime;
            waterMaterial.normalMap.offset.y += params.currentSpeedY * deltaTime;
        }
    }, [waterState]);

    return waterState ? { ...waterState, updateAnimation } : null;
};

export default useWater;

## src\components\HexMap\hooks\useWeatherEffects.js ##
// src/components/HexMap/hooks/useWeatherEffects.js
import { useEffect, useRef, useState, useCallback } from 'react';
import * as THREE from 'three';
import {
    WEATHER_TYPES, SEASONS,
    RAIN_PARTICLE_COUNT, RAIN_AREA_XZ_FACTOR, RAIN_AREA_Y_MAX, RAIN_FALL_SPEED,
    RAIN_PARTICLE_SIZE, RAIN_PARTICLE_OPACITY, RAIN_COLOR,
    SNOW_PARTICLE_COUNT, SNOW_AREA_XZ_FACTOR, SNOW_AREA_Y_MAX, SNOW_FALL_SPEED,
    SNOW_PARTICLE_SIZE, SNOW_PARTICLE_OPACITY, SNOW_PARTICLE_TEXTURE_URL,
    SNOW_DRIFT_SPEED_X_FACTOR, SNOW_DRIFT_SPEED_Z_FACTOR
} from '../constants';

const useWeatherEffects = (coreElements, weatherCondition, season) => {
    const [weatherEffectsState, setWeatherEffectsState] = useState({ isReady: false, hasInitializedOnce: false });
    const rainParticlesRef = useRef(null);
    const rainMaterialRef = useRef(null);
    const snowParticlesRef = useRef(null);
    const snowMaterialRef = useRef(null);
    const snowTextureRef = useRef(null);
    const textureLoaderRef = useRef(null);


    useEffect(() => {
        if (!coreElements || !coreElements.isReady || !coreElements.scene || !(coreElements.scene instanceof THREE.Scene) ||
            coreElements.worldMapWidth === undefined || coreElements.worldMapDepth === undefined) {
            if (weatherEffectsState.isReady) setWeatherEffectsState(prev => ({ ...prev, isReady: false }));
            return;
        }
        if (weatherEffectsState.hasInitializedOnce) { // Prevent re-initialization if coreElements reference changes but is still valid
            if (!weatherEffectsState.isReady) setWeatherEffectsState(prev => ({ ...prev, isReady: true }));
            return;
        }


        const { scene, worldMapWidth, worldMapDepth } = coreElements;
        console.log("useWeatherEffects: Initializing weather systems...");
        textureLoaderRef.current = new THREE.TextureLoader();

        // --- Rain Setup ---
        const rainParticleGeometry = new THREE.BufferGeometry();
        const rainPositions = new Float32Array(RAIN_PARTICLE_COUNT * 3);
        const rainVelocities = new Float32Array(RAIN_PARTICLE_COUNT * 3);
        const rainSpawnAreaWidth = worldMapWidth * RAIN_AREA_XZ_FACTOR;
        const rainSpawnAreaDepth = worldMapDepth * RAIN_AREA_XZ_FACTOR;

        for (let i = 0; i < RAIN_PARTICLE_COUNT; i++) {
            rainPositions[i * 3 + 0] = (Math.random() - 0.5) * rainSpawnAreaWidth;
            rainPositions[i * 3 + 1] = Math.random() * RAIN_AREA_Y_MAX;
            rainPositions[i * 3 + 2] = (Math.random() - 0.5) * rainSpawnAreaDepth;
            rainVelocities[i * 3 + 1] = -(Math.random() * 0.5 + 0.5) * RAIN_FALL_SPEED;
        }
        rainParticleGeometry.setAttribute('position', new THREE.BufferAttribute(rainPositions, 3));
        rainParticleGeometry.setAttribute('velocity', new THREE.BufferAttribute(rainVelocities, 3));
        rainMaterialRef.current = new THREE.PointsMaterial({
            color: RAIN_COLOR, size: RAIN_PARTICLE_SIZE, transparent: true,
            opacity: RAIN_PARTICLE_OPACITY, depthWrite: false, sizeAttenuation: true,
        });
        rainParticlesRef.current = new THREE.Points(rainParticleGeometry, rainMaterialRef.current);
        rainParticlesRef.current.visible = false; rainParticlesRef.current.name = "RainParticles";
        scene.add(rainParticlesRef.current);

        // --- Snow Setup ---
        snowTextureRef.current = textureLoaderRef.current.load(SNOW_PARTICLE_TEXTURE_URL, (texture) => {
            console.log("useWeatherEffects: Snow texture loaded.");
            if (snowMaterialRef.current) {
                snowMaterialRef.current.map = texture;
                snowMaterialRef.current.needsUpdate = true;
            }
        });
        const snowParticleGeometry = new THREE.BufferGeometry();
        const snowPositions = new Float32Array(SNOW_PARTICLE_COUNT * 3);
        const snowVelocities = new Float32Array(SNOW_PARTICLE_COUNT * 3); // x, y, z for drift
        const snowSpawnAreaWidth = worldMapWidth * SNOW_AREA_XZ_FACTOR;
        const snowSpawnAreaDepth = worldMapDepth * SNOW_AREA_XZ_FACTOR;

        for (let i = 0; i < SNOW_PARTICLE_COUNT; i++) {
            snowPositions[i * 3 + 0] = (Math.random() - 0.5) * snowSpawnAreaWidth;
            snowPositions[i * 3 + 1] = Math.random() * SNOW_AREA_Y_MAX;
            snowPositions[i * 3 + 2] = (Math.random() - 0.5) * snowSpawnAreaDepth;

            snowVelocities[i * 3 + 0] = (Math.random() - 0.5) * SNOW_DRIFT_SPEED_X_FACTOR * SNOW_FALL_SPEED; // Horizontal drift
            snowVelocities[i * 3 + 1] = -(Math.random() * 0.4 + 0.6) * SNOW_FALL_SPEED; // Vertical fall
            snowVelocities[i * 3 + 2] = (Math.random() - 0.5) * SNOW_DRIFT_SPEED_Z_FACTOR * SNOW_FALL_SPEED; // Horizontal drift
        }
        snowParticleGeometry.setAttribute('position', new THREE.BufferAttribute(snowPositions, 3));
        snowParticleGeometry.setAttribute('velocity', new THREE.BufferAttribute(snowVelocities, 3));
        snowMaterialRef.current = new THREE.PointsMaterial({
            map: snowTextureRef.current, size: SNOW_PARTICLE_SIZE, transparent: true,
            opacity: SNOW_PARTICLE_OPACITY, depthWrite: false, sizeAttenuation: true,
            blending: THREE.AdditiveBlending, // Brighter snowflakes
        });
        snowParticlesRef.current = new THREE.Points(snowParticleGeometry, snowMaterialRef.current);
        snowParticlesRef.current.visible = false; snowParticlesRef.current.name = "SnowParticles";
        scene.add(snowParticlesRef.current);

        console.log("useWeatherEffects: Weather systems created, setting state.");
        setWeatherEffectsState({ isReady: true, hasInitializedOnce: true });

        return () => {
            console.log("useWeatherEffects: Cleaning up weather systems...");
            if (rainParticlesRef.current) {
                if (rainParticlesRef.current.parent) scene.remove(rainParticlesRef.current);
                rainParticlesRef.current.geometry?.dispose();
            }
            if (rainMaterialRef.current) rainMaterialRef.current.dispose();
            rainParticlesRef.current = null; rainMaterialRef.current = null;

            if (snowParticlesRef.current) {
                if (snowParticlesRef.current.parent) scene.remove(snowParticlesRef.current);
                snowParticlesRef.current.geometry?.dispose();
            }
            if (snowMaterialRef.current) snowMaterialRef.current.dispose();
            if (snowTextureRef.current) snowTextureRef.current.dispose();
            snowParticlesRef.current = null; snowMaterialRef.current = null; snowTextureRef.current = null;

            setWeatherEffectsState({ isReady: false, hasInitializedOnce: false });
        };
    }, [coreElements]); // Only re-init if coreElements itself changes identity and is not ready.

    const updateRain = useCallback((deltaTime) => {
        if (!weatherEffectsState.isReady || !rainParticlesRef.current || !coreElements?.isReady || !coreElements.camera) return;

        const isRainActive = weatherCondition === WEATHER_TYPES.RAINY;
        rainParticlesRef.current.visible = isRainActive;
        if (!isRainActive) return;

        const { camera, worldMapWidth, worldMapDepth } = coreElements;
        rainParticlesRef.current.position.set(camera.position.x, 0, camera.position.z);

        const positions = rainParticlesRef.current.geometry.attributes.position.array;
        const velocities = rainParticlesRef.current.geometry.attributes.velocity.array;
        const spawnAreaWidth = worldMapWidth * RAIN_AREA_XZ_FACTOR;
        const spawnAreaDepth = worldMapDepth * RAIN_AREA_XZ_FACTOR;

        for (let i = 0; i < RAIN_PARTICLE_COUNT; i++) {
            positions[i * 3 + 1] += velocities[i * 3 + 1] * deltaTime;
            if (positions[i * 3 + 1] < 0) {
                positions[i * 3 + 0] = (Math.random() - 0.5) * spawnAreaWidth;
                positions[i * 3 + 1] = RAIN_AREA_Y_MAX * (0.8 + Math.random() * 0.4);
                positions[i * 3 + 2] = (Math.random() - 0.5) * spawnAreaDepth;
            }
        }
        rainParticlesRef.current.geometry.attributes.position.needsUpdate = true;
    }, [weatherEffectsState.isReady, weatherCondition, coreElements]);

    const updateSnow = useCallback((deltaTime) => {
        if (!weatherEffectsState.isReady || !snowParticlesRef.current || !coreElements?.isReady || !coreElements.camera) return;

        const isSnowActive = weatherCondition === WEATHER_TYPES.SNOW && season === SEASONS.WINTER;
        snowParticlesRef.current.visible = isSnowActive;
        if (!isSnowActive) return;

        const { camera, worldMapWidth, worldMapDepth } = coreElements;
        snowParticlesRef.current.position.set(camera.position.x, 0, camera.position.z);

        const positions = snowParticlesRef.current.geometry.attributes.position.array;
        const velocities = snowParticlesRef.current.geometry.attributes.velocity.array;
        const spawnAreaWidth = worldMapWidth * SNOW_AREA_XZ_FACTOR;
        const spawnAreaDepth = worldMapDepth * SNOW_AREA_XZ_FACTOR;
        const spawnAreaY = SNOW_AREA_Y_MAX;

        for (let i = 0; i < SNOW_PARTICLE_COUNT; i++) {
            positions[i * 3 + 0] += velocities[i * 3 + 0] * deltaTime;
            positions[i * 3 + 1] += velocities[i * 3 + 1] * deltaTime;
            positions[i * 3 + 2] += velocities[i * 3 + 2] * deltaTime;

            if (positions[i * 3 + 1] < 0) { // Particle has fallen below ground
                positions[i * 3 + 0] = (Math.random() - 0.5) * spawnAreaWidth; // Reset X
                positions[i * 3 + 1] = spawnAreaY * (0.9 + Math.random() * 0.2);   // Reset Y to top
                positions[i * 3 + 2] = (Math.random() - 0.5) * spawnAreaDepth; // Reset Z
            }
            // Optional: boundary checks for X and Z if particles drift too far from camera-centered spawn
            // This simple reset works well if the spawn area is large enough relative to drift.
        }
        snowParticlesRef.current.geometry.attributes.position.needsUpdate = true;

    }, [weatherEffectsState.isReady, weatherCondition, season, coreElements]);

    return weatherEffectsState.isReady ? { isReady: true, updateRain, updateSnow } : { isReady: false };
};

export default useWeatherEffects;

## src\components\HexMap\hooks\useWorldGeometry.js ##
// src/components/HexMap/hooks/useWorldGeometry.js
import { useEffect, useRef, useState, useCallback } from 'react';
import * as THREE from 'three';
import {
    HEX_SIZE, HEX_HEIGHT_MAX, TILE_TYPES, TILE_COLORS, SEASONS, WEATHER_TYPES,
    SNOW_COVER_COLOR, MAX_SNOW_COVER_LERP_FACTOR, BUILDING_TYPES,
    MIN_TREES_PER_FOREST_TILE, MAX_ADDITIONAL_TREES_PER_FOREST_TILE, PROBABILITY_OF_ADDITIONAL_TREE,
    ROCKS_PER_STONE_TILE_MIN, ROCKS_PER_STONE_TILE_MAX, PROBABILITY_OF_ROCK_ON_STONE_TILE,
    REED_CLUMPS_PER_ELIGIBLE_TILE_MIN, REED_CLUMPS_PER_ELIGIBLE_TILE_MAX, PROBABILITY_OF_REEDS_ON_ELIGIBLE_TILE,
    TRANSPARENT_LAYER_Y
} from '../constants';
import { createHexagonGeometry, createHexagonInstance } from '../utils/threeUtils';
import { createCypressTree, disposeTreeMaterial, updateTreeMaterialsForSnow } from '../utils/treeUtils';
import { createRock, disposeRockMaterials, updateRockMaterialsForSnow } from '../utils/rockUtils';
import { createReedClump, disposeReedMaterial, updateReedMaterialsForSnow } from '../utils/reedsUtils';

const POINTY_HEX_TRUE_WIDTH_CALC = HEX_SIZE * Math.sqrt(3);
const POINTY_HEX_TRUE_HEIGHT_CALC = HEX_SIZE * 2;
const POINTY_HEX_VERT_SPACING_CALC = POINTY_HEX_TRUE_HEIGHT_CALC * 0.75;

const getTileKey = (c, r) => `${c},${r}`;

const useWorldGeometry = (coreElements, islandHeightData, weatherCondition, season, snowAccumulationRatio, getBuildingOnTileFromParent) => {
    const [worldGeoState, setWorldGeoState] = useState(null);
    const treeAnimationIndexRef = useRef(0);
    const reedAnimationIndexRef = useRef(0);
    const originalHexMaterialColorsRef = useRef(new Map()); // Used again for MeshStandardMaterial

    useEffect(() => {
        if (!coreElements || !coreElements.isReady || !coreElements.scene || !(coreElements.scene instanceof THREE.Scene) ||
            !islandHeightData || islandHeightData.size === 0) {
            if (worldGeoState) {
                setWorldGeoState(null);
            }
            return;
        }

        const { scene, worldMapWidth, worldMapDepth } = coreElements;

        console.log(`useWorldGeometry: Initializing with MeshStandardMaterial. Using Scene ID: ${scene.uuid}`);
        originalHexMaterialColorsRef.current.clear();

        const hexGridGroup = new THREE.Group(); hexGridGroup.renderOrder = 0; hexGridGroup.name = "HexGridGroup";
        if (scene.getObjectByName("HexGridGroup")) {
            const oldGroup = scene.getObjectByName("HexGridGroup"); oldGroup.clear(); scene.remove(oldGroup);
        }
        scene.add(hexGridGroup);

        const treeGroup = new THREE.Group(); treeGroup.renderOrder = 0; treeGroup.name = "TreeGroup"; scene.add(treeGroup);
        const rockGroup = new THREE.Group(); rockGroup.renderOrder = 0; rockGroup.name = "RockGroup"; scene.add(rockGroup);
        const reedGroup = new THREE.Group(); reedGroup.renderOrder = 0; reedGroup.name = "ReedGroup"; scene.add(reedGroup);

        const animatedTrees = [];
        const animatedReeds = [];
        const landTiles = [];
        const landTileMap = new Map();
        const hexMeshesForRaycasting = [];

        const gridOffsetX = worldMapWidth / 2 - POINTY_HEX_TRUE_WIDTH_CALC / 2;
        const gridOffsetZ = worldMapDepth / 2 - POINTY_HEX_VERT_SPACING_CALC / 2;

        islandHeightData.forEach((tileData, key) => {
            const [c_str, r_str] = key.split(',');
            const c = parseInt(c_str, 10);
            const r = parseInt(r_str, 10);
            const totalWorldHeightFromBase = tileData.normalizedElevation * HEX_HEIGHT_MAX;

            const xOffsetForRow = (r % 2 === 1) ? POINTY_HEX_TRUE_WIDTH_CALC / 2 : 0;
            const worldX = c * POINTY_HEX_TRUE_WIDTH_CALC + xOffsetForRow - gridOffsetX;
            const worldZ = r * POINTY_HEX_VERT_SPACING_CALC - gridOffsetZ;

            const currentTileFullData = {
                x: worldX, z: worldZ, y: 0,
                r: r, c: c,
                type: tileData.type,
                normalizedElevation: tileData.normalizedElevation,
                tileKey: key
            };

            if (tileData.type !== TILE_TYPES.DEEP_WATER && tileData.type !== TILE_TYPES.SHALLOW_WATER) {
                const hexRenderHeight = Math.max(0.05, totalWorldHeightFromBase);
                const hexYPosition = hexRenderHeight / 2;
                currentTileFullData.y = hexRenderHeight;

                const hexGeometry = createHexagonGeometry(HEX_SIZE, hexRenderHeight);
                const tileHexColor = TILE_COLORS[tileData.type] || 0x7F7F7F;
                // Revert to MeshStandardMaterial
                const tileMaterial = new THREE.MeshStandardMaterial({
                    color: tileHexColor,
                    metalness: 0.1,
                    roughness: 0.85,
                    flatShading: true, // Note: for true flat shading, geometry normals matter most
                });
                originalHexMaterialColorsRef.current.set(tileMaterial, { color: tileMaterial.color.clone(), c, r });


                const hexInstance = createHexagonInstance(hexGeometry, tileMaterial, worldX, hexYPosition, worldZ);
                hexInstance.userData = {
                    isHexTile: true,
                    c: c,
                    r: r,
                    tileKey: key,
                    tileData: currentTileFullData
                };
                hexGridGroup.add(hexInstance);
                hexMeshesForRaycasting.push(hexInstance);
                landTiles.push(currentTileFullData);

                if (tileData.type === TILE_TYPES.FOREST) {
                    const placeSingleTree = () => {
                        const treeObject = createCypressTree(undefined, undefined, tileData.normalizedElevation);
                        const maxOffsetFactor = 0.75;
                        const r_offset = Math.sqrt(Math.random()) * HEX_SIZE * maxOffsetFactor;
                        const angle_offset = Math.random() * Math.PI * 2;
                        const randomXOffset = r_offset * Math.cos(angle_offset);
                        const randomZOffset = r_offset * Math.sin(angle_offset);
                        treeObject.position.set(worldX + randomXOffset, currentTileFullData.y, worldZ + randomZOffset);
                        treeObject.rotation.y = Math.random() * Math.PI * 2;
                        treeObject.userData.windPhaseOffset = Math.random() * Math.PI * 2;
                        treeObject.userData.windSpeedMultiplier = 0.8 + Math.random() * 0.4;
                        treeGroup.add(treeObject); animatedTrees.push(treeObject);
                    };
                    for (let i = 0; i < MIN_TREES_PER_FOREST_TILE; i++) placeSingleTree();
                    for (let i = 0; i < MAX_ADDITIONAL_TREES_PER_FOREST_TILE; i++) {
                        if (Math.random() < PROBABILITY_OF_ADDITIONAL_TREE) placeSingleTree();
                    }
                }
                if (tileData.type === TILE_TYPES.STONE || tileData.type === TILE_TYPES.MOUNTAIN_PEAK) {
                    if (Math.random() < PROBABILITY_OF_ROCK_ON_STONE_TILE) {
                        const numRocks = Math.floor(Math.random() * (ROCKS_PER_STONE_TILE_MAX - ROCKS_PER_STONE_TILE_MIN + 1)) + ROCKS_PER_STONE_TILE_MIN;
                        for (let i = 0; i < numRocks; i++) {
                            const rock = createRock();
                            const maxOffsetFactor = 0.8;
                            const r_offset = Math.sqrt(Math.random()) * HEX_SIZE * maxOffsetFactor;
                            const angle_offset = Math.random() * Math.PI * 2;
                            const randomXOffset = r_offset * Math.cos(angle_offset);
                            const randomZOffset = r_offset * Math.sin(angle_offset);
                            rock.position.set(worldX + randomXOffset, currentTileFullData.y, worldZ + randomZOffset);
                            rock.rotation.set(Math.random() * Math.PI * 2, Math.random() * Math.PI * 2, Math.random() * Math.PI * 2);
                            rockGroup.add(rock);
                        }
                    }
                }

            } else if (tileData.type === TILE_TYPES.SHALLOW_WATER) {
                currentTileFullData.y = TRANSPARENT_LAYER_Y;
                if (Math.random() < PROBABILITY_OF_REEDS_ON_ELIGIBLE_TILE) {
                    const numClumps = Math.floor(Math.random() * (REED_CLUMPS_PER_ELIGIBLE_TILE_MAX - REED_CLUMPS_PER_ELIGIBLE_TILE_MIN + 1)) + REED_CLUMPS_PER_ELIGIBLE_TILE_MIN;
                    const reedBedY = TRANSPARENT_LAYER_Y - 0.04;
                    for (let i = 0; i < numClumps; i++) {
                        const reedClump = createReedClump();
                        const maxOffsetFactor = 0.85;
                        const r_offset = Math.sqrt(Math.random()) * HEX_SIZE * maxOffsetFactor;
                        const angle_offset = Math.random() * Math.PI * 2;
                        const randomXOffset = r_offset * Math.cos(angle_offset);
                        const randomZOffset = r_offset * Math.sin(angle_offset);
                        reedClump.position.set(worldX + randomXOffset, reedBedY, worldZ + randomZOffset);
                        reedClump.userData.windPhaseOffset = Math.random() * Math.PI * 2;
                        reedClump.userData.windSpeedMultiplier = 0.7 + Math.random() * 0.6;
                        reedGroup.add(reedClump); animatedReeds.push(reedClump);
                    }
                }
            } else {
                currentTileFullData.y = TRANSPARENT_LAYER_Y - 0.5;
            }
            landTileMap.set(key, currentTileFullData);
        });

        console.log("useWorldGeometry: Geometry created, setting state. Land Tile Map size:", landTileMap.size, "Hex meshes:", hexMeshesForRaycasting.length);
        setWorldGeoState({
            hexGridGroup, treeGroup, rockGroup, reedGroup,
            animatedTrees, animatedReeds, landTiles, landTileMap,
            hexMeshesForRaycasting,
            isReady: true
        });

        return () => {
            console.log(`useWorldGeometry: Cleaning up from scene: ${scene.uuid}. Disposing standard materials...`);
            // No separate hexMaterialsRef for MeshStandardMaterial, they are on the meshes.
            // originalHexMaterialColorsRef only stores colors, not materials themselves for disposal.

            const disposeAndRemoveGroup = (groupToRemove, disposeSharedMaterialFn) => {
                if (groupToRemove) {
                    groupToRemove.traverse(node => {
                        if (node.isMesh) {
                            if (node.geometry) node.geometry.dispose();
                            if (node.material) { // Dispose all materials on ungroup
                                if (Array.isArray(node.material)) {
                                    node.material.forEach(m => m.dispose());
                                } else {
                                    node.material.dispose();
                                }
                            }
                        }
                    });
                    groupToRemove.clear();
                    if (scene && groupToRemove.parent === scene) {
                        scene.remove(groupToRemove);
                    } else if (groupToRemove.parent) {
                        groupToRemove.parent.remove(groupToRemove);
                    }
                }
                if (disposeSharedMaterialFn) disposeSharedMaterialFn();
            };

            disposeAndRemoveGroup(hexGridGroup); // Will dispose hex MeshStandardMaterials
            disposeAndRemoveGroup(treeGroup, disposeTreeMaterial);
            disposeAndRemoveGroup(rockGroup, disposeRockMaterials);
            disposeAndRemoveGroup(reedGroup, disposeReedMaterial);

            originalHexMaterialColorsRef.current.clear();
            treeAnimationIndexRef.current = 0;
            reedAnimationIndexRef.current = 0;
            setWorldGeoState(null);
        };
    }, [coreElements, islandHeightData]);

    useEffect(() => {
        if (!worldGeoState || !worldGeoState.isReady || snowAccumulationRatio === undefined || typeof getBuildingOnTileFromParent !== 'function') {
            return;
        }

        const snowCoverMainColor = new THREE.Color(SNOW_COVER_COLOR);

        // Iterate over originalHexMaterialColorsRef to update MeshStandardMaterial instances
        originalHexMaterialColorsRef.current.forEach((matInfo, materialInstance) => {
            let currentLerpFactor = snowAccumulationRatio * MAX_SNOW_COVER_LERP_FACTOR;

            const buildingOnTile = getBuildingOnTileFromParent(matInfo.c, matInfo.r);
            if (buildingOnTile && buildingOnTile.type === BUILDING_TYPES.CAMPFIRE && buildingOnTile.isLit) {
                currentLerpFactor = 0.01; // Reduce snow on tile if campfire is lit
            }

            materialInstance.color.copy(matInfo.color).lerp(snowCoverMainColor, currentLerpFactor);
            // materialInstance.needsUpdate = true; // For MeshStandardMaterial, color change is usually direct
        });


        updateTreeMaterialsForSnow(snowAccumulationRatio);
        updateRockMaterialsForSnow(snowAccumulationRatio);
        updateReedMaterialsForSnow(snowAccumulationRatio);

    }, [worldGeoState, snowAccumulationRatio, getBuildingOnTileFromParent]);


    const updateAnimations = useCallback((elapsedTime) => {
        if (!worldGeoState || !worldGeoState.isReady) return;
        const { animatedTrees, animatedReeds } = worldGeoState;

        const ANIMATION_UPDATE_STRIDE = 3;
        const TREE_WIND_SPEED = 0.7;
        const TREE_WIND_STRENGTH = 0.03;
        const REED_WIND_SPEED = 1.2;
        const REED_WIND_STRENGTH = 0.07;

        const animateStaggered = (items, indexRef, speed, strength, axis = 'z', secondAxis = null, secondAxisFactor = 0.6) => {
            if (!items || items.length === 0) return;
            const numItems = items.length;
            const itemsToUpdate = Math.max(1, Math.ceil(numItems / ANIMATION_UPDATE_STRIDE));
            for (let i = 0; i < itemsToUpdate; i++) {
                const currentIndex = (indexRef.current + i) % numItems;
                const item = items[currentIndex];
                if (item?.userData) {
                    const phase = item.userData.windPhaseOffset || 0;
                    const speedMult = item.userData.windSpeedMultiplier || 1;
                    item.rotation[axis] = Math.sin(elapsedTime * speed * speedMult + phase) * strength;
                    if (secondAxis) {
                        item.rotation[secondAxis] = Math.cos(elapsedTime * speed * 0.8 * speedMult + phase + Math.PI / 2) * strength * secondAxisFactor;
                    }
                }
            }
            indexRef.current = (indexRef.current + itemsToUpdate) % numItems;
        };
        animateStaggered(animatedTrees, treeAnimationIndexRef, TREE_WIND_SPEED, TREE_WIND_STRENGTH);
        animateStaggered(animatedReeds, reedAnimationIndexRef, REED_WIND_SPEED, REED_WIND_STRENGTH, 'z', 'x');
    }, [worldGeoState]);

    return worldGeoState ? { ...worldGeoState, updateAnimations } : null;
};

export default useWorldGeometry;

## src\components\HexMap\ui\BuildingPalette.jsx ##
[Error reading file: 'utf-8' codec can't decode byte 0xb0 in position 2923: invalid start byte]

## src\components\HexMap\ui\SunControls.jsx ##
// src/components/HexMap/ui/SunControls.jsx
import React from 'react';
import { SEASONS, WEATHER_TYPES } from '../constants';

const seasonNames = {
    [SEASONS.SPRING]: "Spring", [SEASONS.SUMMER]: "Summer",
    [SEASONS.AUTUMN]: "Autumn", [SEASONS.WINTER]: "Winter",
};

const weatherNames = {
    [WEATHER_TYPES.CLEAR]: "Clear",
    [WEATHER_TYPES.CLOUDY]: "Cloudy",
    [WEATHER_TYPES.RAINY]: "Rainy",
    [WEATHER_TYPES.SNOW]: "Snow", // Added Snow
};

const SunControls = ({
    timeOfDay, setTimeOfDay,
    season, setSeason,
    weather, setWeather,
    currentSunColor, currentMoonColor
}) => {

    const formatTime = (time) => {
        const hours = Math.floor(time);
        const minutes = Math.floor((time - hours) * 60);
        return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
    };

    const handleWeatherChange = (e) => {
        const newWeather = e.target.value;
        // Prevent selecting "Snow" if not winter (optional, can be handled by effects instead)
        // if (newWeather === WEATHER_TYPES.SNOW && season !== SEASONS.WINTER) {
        //     // Optionally alert user or revert to a default weather
        //     setWeather(WEATHER_TYPES.CLEAR); // Or previous weather
        //     alert("Snow is only available in Winter.");
        //     return;
        // }
        setWeather(newWeather);
    };


    return (
        <div style={{
            position: 'absolute',
            top: '20px',
            left: '20px',
            background: 'rgba(0,0,0,0.7)',
            padding: '15px',
            borderRadius: '8px',
            color: 'white',
            fontFamily: 'sans-serif',
            zIndex: 10,
            minWidth: '270px'
        }}>
            <div>
                <label htmlFor="timeOfDay" style={{ display: 'block', marginBottom: '5px' }}>
                    Time of Day: {formatTime(timeOfDay)}
                </label>
                <input
                    type="range" id="timeOfDay" min="0" max="23.99" step="0.05"
                    value={timeOfDay} onChange={(e) => setTimeOfDay(parseFloat(e.target.value))}
                    style={{ width: '100%', display: 'block', marginBottom: '15px' }}
                />
            </div>
            <div>
                <label htmlFor="season" style={{ display: 'block', marginBottom: '5px' }}>
                    Season: {seasonNames[season]}
                </label>
                <input
                    type="range" id="season" min="0" max="3" step="1"
                    value={season} onChange={(e) => {
                        const newSeason = parseInt(e.target.value);
                        setSeason(newSeason);
                        // If current weather is snow and new season is not winter, change weather
                        if (weather === WEATHER_TYPES.SNOW && newSeason !== SEASONS.WINTER) {
                            setWeather(WEATHER_TYPES.CLEAR); // or CLOUDY
                        }
                    }}
                    style={{ width: '100%', display: 'block', marginBottom: '10px' }}
                />
            </div>
            <div>
                <label htmlFor="weather" style={{ display: 'block', marginBottom: '5px' }}>
                    Weather: {weatherNames[weather]}
                </label>
                <select
                    id="weather"
                    value={weather}
                    onChange={handleWeatherChange}
                    style={{ width: '100%', padding: '5px', marginBottom: '15px', background: '#333', color: 'white', border: '1px solid #555' }}
                >
                    {Object.entries(weatherNames).map(([key, name]) => {
                        // Conditionally disable Snow option if not Winter
                        const disabled = key === WEATHER_TYPES.SNOW && season !== SEASONS.WINTER;
                        return (
                            <option key={key} value={key} disabled={disabled} style={disabled ? { color: '#888' } : {}}>
                                {name}
                            </option>
                        );
                    })}
                </select>
            </div>
            <div style={{ marginTop: '10px', display: 'flex', alignItems: 'center' }}>
                Sun Color:
                <span style={{
                    display: 'inline-block', width: '20px', height: '20px',
                    backgroundColor: currentSunColor ? `#${currentSunColor.getHexString()}` : '#FFFFFF',
                    border: '1px solid white', marginLeft: '8px', verticalAlign: 'middle'
                }}></span>
            </div>
            {currentMoonColor && (
                <div style={{ marginTop: '10px', display: 'flex', alignItems: 'center' }}>
                    Moon Color:
                    <span style={{
                        display: 'inline-block', width: '20px', height: '20px',
                        backgroundColor: `#${currentMoonColor.getHexString()}`,
                        border: '1px solid white', marginLeft: '8px', verticalAlign: 'middle'
                    }}></span>
                </div>
            )}
        </div>
    );
};

export default SunControls;

## src\components\HexMap\utils\buildingUtils.js ##
// src/components/HexMap/utils/buildingUtils.js
import * as THREE from 'three';
import { SNOW_COVER_COLOR, MAX_SNOW_COVER_LERP_FACTOR, BUILDING_TYPES } from '../constants';

// Store original materials to revert snow or for efficient reuse
const buildingMaterialsCache = new Map(); // Key: material, Value: { originalColor: Color, originalEmissive?: Color }

const getCachedMaterial = (colorHex, props = {}, isFlame = false) => {
    const material = new THREE.MeshStandardMaterial({ color: colorHex, ...props });
    if (!isFlame) {
        const cacheEntry = { originalColor: material.color.clone() };
        if (material.emissive) {
            cacheEntry.originalEmissive = material.emissive.clone();
        }
        buildingMaterialsCache.set(material, cacheEntry);
    }
    return material;
};

// --- House ---
const HOUSE_WALL_COLOR = 0xD2B48C; // Tan
const HOUSE_ROOF_COLOR = 0xA52A2A; // Brown
const HOUSE_DOOR_COLOR = 0x8B4513; // SaddleBrown
const HOUSE_WINDOW_COLOR = 0xADD8E6; // LightBlue - Base color for glass
const HOUSE_WINDOW_EMISSIVE_COLOR = 0xFFFFAA; // Warm yellow glow for windows
const HOUSE_LAMP_EMISSIVE_COLOR = 0xFFE082;  // Slightly different warm glow for lamp
const HOUSE_FRAME_COLOR = 0x7A5230; // Darker brown for frames
const CHIMNEY_COLOR = 0x8B4513;
const ROOF_PANEL_THICKNESS = 0.04;
const LAMP_POST_COLOR = 0x505050; // Dark grey metal for lamp post
const LAMP_SHADE_COLOR = 0xF0E68C; // Khaki / light yellow for shade

const createHouseModel = (tileY) => {
    const houseGroup = new THREE.Group();
    houseGroup.userData.isBuilding = true;
    houseGroup.userData.buildingType = BUILDING_TYPES.HOUSE;

    const baseHeight = 0.6;
    const baseWidth = 0.7;
    const baseDepth = 0.6;

    const wallMaterial = getCachedMaterial(HOUSE_WALL_COLOR, { roughness: 0.8, metalness: 0.1 });
    const baseGeo = new THREE.BoxGeometry(baseWidth, baseHeight, baseDepth);
    const baseMesh = new THREE.Mesh(baseGeo, wallMaterial);
    baseMesh.position.y = tileY + baseHeight / 2;
    baseMesh.castShadow = true;
    baseMesh.receiveShadow = true;
    houseGroup.add(baseMesh);

    const roofMaterial = getCachedMaterial(HOUSE_ROOF_COLOR, { roughness: 0.7, metalness: 0.1 });
    roofMaterial.userData = { isRoof: true };
    const frameMaterial = getCachedMaterial(HOUSE_FRAME_COLOR, { roughness: 0.8 });

    const roofOverhangX = 0.05;
    const roofOverhangZ = 0.05;
    const roofPitchHeight = 0.35;

    const panelCuboidLength = baseDepth + 2 * roofOverhangZ;
    const panelCuboidWidth = Math.sqrt(Math.pow(baseWidth / 2 + roofOverhangX, 2) + Math.pow(roofPitchHeight, 2));

    const roofPanelGeo = new THREE.BoxGeometry(panelCuboidWidth, ROOF_PANEL_THICKNESS, panelCuboidLength);
    const slopeAngle = Math.atan2(roofPitchHeight, baseWidth / 2 + roofOverhangX);

    const panel1CenterX = (baseWidth / 2 + roofOverhangX - ROOF_PANEL_THICKNESS * Math.sin(slopeAngle)) / 2;
    const panel2CenterX = -(baseWidth / 2 + roofOverhangX - ROOF_PANEL_THICKNESS * Math.sin(slopeAngle)) / 2;
    const panelCenterY = tileY + baseHeight + (roofPitchHeight / 2) - (ROOF_PANEL_THICKNESS * Math.cos(slopeAngle)) / 4;

    const roofPanel1 = new THREE.Mesh(roofPanelGeo, roofMaterial);
    roofPanel1.userData.isRoof = true;
    roofPanel1.castShadow = true;
    roofPanel1.position.set(panel1CenterX, panelCenterY, 0);
    roofPanel1.rotation.z = -slopeAngle;
    houseGroup.add(roofPanel1);

    const roofPanel2 = new THREE.Mesh(roofPanelGeo, roofMaterial);
    roofPanel2.userData.isRoof = true;
    roofPanel2.castShadow = true;
    roofPanel2.position.set(panel2CenterX, panelCenterY, 0);
    roofPanel2.rotation.z = slopeAngle;
    houseGroup.add(roofPanel2);

    const ridgeCapLength = panelCuboidLength;
    const ridgeCapWidth = ROOF_PANEL_THICKNESS * 1.5;
    const ridgeCapHeight = ROOF_PANEL_THICKNESS * 1.2;
    const ridgeCapGeo = new THREE.BoxGeometry(ridgeCapWidth, ridgeCapHeight, ridgeCapLength);
    const ridgeCapMesh = new THREE.Mesh(ridgeCapGeo, frameMaterial);
    ridgeCapMesh.userData.isRoof = true;
    ridgeCapMesh.position.set(0, tileY + baseHeight + roofPitchHeight + ROOF_PANEL_THICKNESS / 2 - ridgeCapHeight / 3, 0);
    ridgeCapMesh.castShadow = true;
    houseGroup.add(ridgeCapMesh);

    const gableGeo = new THREE.BufferGeometry();
    const gableVertices = new Float32Array([
        -baseWidth / 2, baseHeight, baseDepth / 2,
        baseWidth / 2, baseHeight, baseDepth / 2,
        0, baseHeight + roofPitchHeight, baseDepth / 2,
        baseWidth / 2, baseHeight, -baseDepth / 2,
        -baseWidth / 2, baseHeight, -baseDepth / 2,
        0, baseHeight + roofPitchHeight, -baseDepth / 2,
    ]);
    for (let i = 0; i < gableVertices.length / 3; i++) {
        gableVertices[i * 3 + 1] += tileY;
    }
    gableGeo.setAttribute('position', new THREE.BufferAttribute(gableVertices, 3));
    gableGeo.computeVertexNormals();
    const gableMesh = new THREE.Mesh(gableGeo, wallMaterial);
    gableMesh.castShadow = true;
    houseGroup.add(gableMesh);

    const doorHeight = 0.35;
    const doorWidth = 0.15;
    const doorDepth = 0.03;
    const doorMaterial = getCachedMaterial(HOUSE_DOOR_COLOR, { roughness: 0.9 });
    const doorGeo = new THREE.BoxGeometry(doorWidth, doorHeight, doorDepth);
    const doorMesh = new THREE.Mesh(doorGeo, doorMaterial);
    doorMesh.position.set(0, tileY + doorHeight / 2, baseDepth / 2 - doorDepth / 2 + 0.001);
    doorMesh.castShadow = true;
    houseGroup.add(doorMesh);

    const frameThickness = 0.025;
    const doorFrameSideGeo = new THREE.BoxGeometry(frameThickness, doorHeight + frameThickness, frameThickness);
    const doorFrameTopGeo = new THREE.BoxGeometry(doorWidth + frameThickness * 2, frameThickness, frameThickness);

    const doorFrameLeft = new THREE.Mesh(doorFrameSideGeo, frameMaterial);
    doorFrameLeft.position.set(-doorWidth / 2 - frameThickness / 2, tileY + (doorHeight + frameThickness) / 2, baseDepth / 2 + 0.005);
    houseGroup.add(doorFrameLeft);

    const doorFrameRight = new THREE.Mesh(doorFrameSideGeo, frameMaterial);
    doorFrameRight.position.set(doorWidth / 2 + frameThickness / 2, tileY + (doorHeight + frameThickness) / 2, baseDepth / 2 + 0.005);
    houseGroup.add(doorFrameRight);

    const doorFrameTop = new THREE.Mesh(doorFrameTopGeo, frameMaterial);
    doorFrameTop.position.set(0, tileY + doorHeight + frameThickness / 2, baseDepth / 2 + 0.005);
    houseGroup.add(doorFrameTop);

    const windowSize = 0.15;
    const windowDepth = 0.02;
    const windowGlassMaterial = getCachedMaterial(HOUSE_WINDOW_COLOR, {
        roughness: 0.2,
        transparent: true,
        opacity: 0.6,
        side: THREE.DoubleSide,
        emissive: HOUSE_WINDOW_EMISSIVE_COLOR,
        emissiveIntensity: 0.0
    });
    const windowGlassGeo = new THREE.BoxGeometry(windowSize, windowSize, windowDepth / 2);

    const createdWindowGlassMaterials = [windowGlassMaterial]; // Store the shared material instance

    const createFramedWindow = (posX, posY, posZ, rotY = 0) => {
        const windowGroup = new THREE.Group();
        windowGroup.position.set(posX, posY, posZ);
        windowGroup.rotation.y = rotY;

        const glass = new THREE.Mesh(windowGlassGeo, windowGlassMaterial);
        windowGroup.add(glass);

        const frameSideGeo = new THREE.BoxGeometry(frameThickness, windowSize + frameThickness * 2, frameThickness);
        const frameTopBottomGeo = new THREE.BoxGeometry(windowSize + frameThickness * 2, frameThickness, frameThickness);

        const frameLeft = new THREE.Mesh(frameSideGeo, frameMaterial);
        frameLeft.position.x = -windowSize / 2 - frameThickness / 2;
        windowGroup.add(frameLeft);

        const frameRight = new THREE.Mesh(frameSideGeo, frameMaterial);
        frameRight.position.x = windowSize / 2 + frameThickness / 2;
        windowGroup.add(frameRight);

        const frameTop = new THREE.Mesh(frameTopBottomGeo, frameMaterial);
        frameTop.position.y = windowSize / 2 + frameThickness / 2;
        windowGroup.add(frameTop);

        const frameBottom = new THREE.Mesh(frameTopBottomGeo, frameMaterial);
        frameBottom.position.y = -windowSize / 2 - frameThickness / 2;
        windowGroup.add(frameBottom);

        const sillGeo = new THREE.BoxGeometry(windowSize + frameThickness * 3, frameThickness * 0.8, frameThickness * 1.5);
        const sill = new THREE.Mesh(sillGeo, frameMaterial);
        sill.position.y = -windowSize / 2 - frameThickness;
        sill.position.z = frameThickness * 0.5;
        windowGroup.add(sill);

        windowGroup.castShadow = true;
        return windowGroup;
    };

    const windowYPos = tileY + baseHeight / 1.7;
    const window1 = createFramedWindow(baseWidth / 2 + frameThickness / 2, windowYPos, 0, Math.PI / 2);
    houseGroup.add(window1);

    const window2 = createFramedWindow(-baseWidth / 2 - frameThickness / 2, windowYPos, 0, -Math.PI / 2);
    houseGroup.add(window2);

    // Chimney
    const chimneyWidth = 0.12;
    const chimneyDepth = 0.12;
    const chimneyHeight = 0.4;
    const chimneyMaterial = getCachedMaterial(CHIMNEY_COLOR, { roughness: 0.85 });
    chimneyMaterial.userData = { isRoof: true };

    const chimneyGeo = new THREE.BoxGeometry(chimneyWidth, chimneyHeight, chimneyDepth);
    const chimneyMesh = new THREE.Mesh(chimneyGeo, chimneyMaterial);

    const chimneyPosX = baseWidth / 4;
    chimneyMesh.position.set(
        chimneyPosX,
        tileY + baseHeight + roofPitchHeight - chimneyHeight * 0.1 + ROOF_PANEL_THICKNESS,
        -baseDepth / 4
    );
    chimneyMesh.castShadow = true;
    houseGroup.add(chimneyMesh);

    // --- Door Lamp ---
    const lampGroup = new THREE.Group();
    const lampPostHeight = 0.25;
    const lampPostRadius = 0.01;
    const lampPostMaterial = getCachedMaterial(LAMP_POST_COLOR, { roughness: 0.6 });
    const lampPostGeo = new THREE.CylinderGeometry(lampPostRadius, lampPostRadius, lampPostHeight, 6);
    const lampPost = new THREE.Mesh(lampPostGeo, lampPostMaterial);
    lampPost.position.y = lampPostHeight / 2; // Base of post on ground
    lampGroup.add(lampPost);

    const lampShadeSize = 0.06;
    const lampShadeMaterial = getCachedMaterial(LAMP_SHADE_COLOR, {
        roughness: 0.7,
        emissive: HOUSE_LAMP_EMISSIVE_COLOR,
        emissiveIntensity: 0.0 // Start off
    });
    // Mark lamp shade as a "roof" like surface for snow, or handle its snow separately if needed
    lampShadeMaterial.userData = { isRoof: true, isLampShade: true };
    const lampShadeGeo = new THREE.BoxGeometry(lampShadeSize, lampShadeSize * 0.8, lampShadeSize); // lantern shape
    const lampShade = new THREE.Mesh(lampShadeGeo, lampShadeMaterial);
    lampShade.position.y = lampPostHeight + (lampShadeSize * 0.8) / 2 - 0.01; // Sit on top of post
    lampGroup.add(lampShade);

    // PointLight for the lamp
    const doorLampLight = new THREE.PointLight(HOUSE_LAMP_EMISSIVE_COLOR, 0, 0.8, 1.5); // color, intensity, distance, decay
    doorLampLight.position.y = lampShade.position.y; // Emanate from shade center
    doorLampLight.castShadow = false; // Keep false for performance unless critical
    lampGroup.add(doorLampLight);

    // Position the lamp group next to the door
    // Decide which side: Math.random() < 0.5 ? -1 : 1;
    const lampSideMultiplier = 1; // Or -1 for other side
    lampGroup.position.set(
        (doorWidth / 2 + frameThickness + lampPostRadius + 0.03) * lampSideMultiplier,
        tileY, // Lamp base on the ground
        baseDepth / 2 + 0.02 // Slightly in front of door frame
    );
    lampGroup.castShadow = true; // Post can cast shadow
    houseGroup.add(lampGroup);
    // Store references for animation
    houseGroup.userData.doorLampLight = doorLampLight;
    houseGroup.userData.doorLampShadeMaterial = lampShadeMaterial;


    // Animation function for house (window lights, door lamp)
    houseGroup.userData.animate = (time, timeOfDay) => {
        let targetWindowIntensity = 0.0;
        let targetLampIntensity = 0.0; // For PointLight
        let targetLampEmissive = 0.0;   // For Lamp Shade Material

        const eveningStart = 17.5;
        const nightStart = 19.5;
        const morningEnd = 7.0;
        const peakWindowIntensity = 0.8;
        const peakLampLightIntensity = 0.7; // For PointLight
        const peakLampEmissiveIntensity = 0.6; // For Shade Material

        if (timeOfDay >= eveningStart && timeOfDay < nightStart) {
            const factor = (timeOfDay - eveningStart) / (nightStart - eveningStart);
            targetWindowIntensity = THREE.MathUtils.lerp(0, peakWindowIntensity, factor);
            targetLampIntensity = THREE.MathUtils.lerp(0, peakLampLightIntensity, factor);
            targetLampEmissive = THREE.MathUtils.lerp(0, peakLampEmissiveIntensity, factor);
        } else if (timeOfDay >= nightStart || timeOfDay < morningEnd - 1) {
            targetWindowIntensity = peakWindowIntensity;
            targetLampIntensity = peakLampLightIntensity;
            targetLampEmissive = peakLampEmissiveIntensity;
        } else if (timeOfDay >= morningEnd - 1 && timeOfDay < morningEnd) {
            const factor = (timeOfDay - (morningEnd - 1)) / 1;
            targetWindowIntensity = THREE.MathUtils.lerp(peakWindowIntensity, 0, factor);
            targetLampIntensity = THREE.MathUtils.lerp(peakLampLightIntensity, 0, factor);
            targetLampEmissive = THREE.MathUtils.lerp(peakLampEmissiveIntensity, 0, factor);
        }

        if (targetWindowIntensity > 0.05) {
            targetWindowIntensity += Math.sin(time * 5 + houseGroup.id * 0.5) * 0.08 * targetWindowIntensity;
            targetWindowIntensity = Math.max(0.05, targetWindowIntensity);
        }
        if (targetLampIntensity > 0.05) {
            targetLampIntensity += Math.sin(time * 4.5 + houseGroup.id * 0.3) * 0.1 * targetLampIntensity;
            targetLampIntensity = Math.max(0.03, targetLampIntensity);
            targetLampEmissive = targetLampIntensity * 0.8; // Link shade emissive to light
        }


        if (createdWindowGlassMaterials.length > 0) {
            const material = createdWindowGlassMaterials[0];
            material.emissiveIntensity = THREE.MathUtils.lerp(material.emissiveIntensity, targetWindowIntensity, 0.1);
            material.needsUpdate = true;
        }

        // Update door lamp
        const lampLight = houseGroup.userData.doorLampLight;
        const lampShadeMat = houseGroup.userData.doorLampShadeMaterial;
        if (lampLight && lampShadeMat) {
            lampLight.intensity = THREE.MathUtils.lerp(lampLight.intensity, targetLampIntensity, 0.1);
            lampShadeMat.emissiveIntensity = THREE.MathUtils.lerp(lampShadeMat.emissiveIntensity, targetLampEmissive, 0.1);
            lampLight.visible = lampLight.intensity > 0.01;
            lampShadeMat.needsUpdate = true;
        }
    };

    return houseGroup;
};

// --- Campfire ---
// (Campfire code remains the same as previous version)
const CAMPFIRE_WOOD_COLOR = 0x8B4513;
const CAMPFIRE_STONE_COLOR = 0x808080;
const FLAME_COLOR_YELLOW = 0xFFFFAA;
const FLAME_COLOR_ORANGE = 0xFFAA33;

const createCampfireModel = (tileY) => {
    const campfireGroup = new THREE.Group();
    campfireGroup.userData.isBuilding = true;
    campfireGroup.userData.buildingType = BUILDING_TYPES.CAMPFIRE;

    const stoneMaterial = getCachedMaterial(CAMPFIRE_STONE_COLOR, { roughness: 0.8, metalness: 0.2 });
    stoneMaterial.userData = { isRoof: true };
    const woodMaterial = getCachedMaterial(CAMPFIRE_WOOD_COLOR, { roughness: 0.9, metalness: 0.05 });
    woodMaterial.userData = { isRoof: true };

    const baseRadius = 0.18;
    const stoneHeight = 0.06;
    const groundY = tileY + stoneHeight / 2;

    for (let i = 0; i < 8; i++) {
        const angle = (i / 8) * Math.PI * 2;
        const stoneGeo = new THREE.BoxGeometry(0.07, stoneHeight, 0.07);
        const stone = new THREE.Mesh(stoneGeo, stoneMaterial);
        stone.position.set(
            Math.cos(angle) * (baseRadius - 0.035),
            groundY,
            Math.sin(angle) * (baseRadius - 0.035)
        );
        stone.castShadow = true;
        campfireGroup.add(stone);
    }

    const logLength = 0.22;
    const logRadius = 0.025;
    const logGeo = new THREE.CylinderGeometry(logRadius, logRadius, logLength, 5);

    const logPositions = [
        { yOff: logRadius, rotZ: Math.PI / 2, rotY: 0, zOff: -logRadius * 1.2 },
        { yOff: logRadius, rotZ: Math.PI / 2, rotY: Math.PI / 2.5, zOff: 0, xOff: logRadius * 0.8 },
        { yOff: logRadius, rotZ: Math.PI / 2, rotY: -Math.PI / 2.5, zOff: 0, xOff: -logRadius * 0.8 },
        { yOff: logRadius * 3, rotZ: Math.PI / 2, rotY: Math.PI / 6, zOff: -logRadius * 0.5 },
    ];

    logPositions.forEach(p => {
        const log = new THREE.Mesh(logGeo, woodMaterial);
        log.rotation.z = p.rotZ;
        if (p.rotY) log.rotation.y = p.rotY;
        log.position.set(p.xOff || 0, groundY - stoneHeight / 2 + p.yOff, p.zOff || 0);
        log.castShadow = true;
        campfireGroup.add(log);
    });

    const numSittingStones = 3 + Math.floor(Math.random() * 3);
    const sittingStoneMinRadius = baseRadius + 0.12;
    const sittingStoneMaxRadius = baseRadius + 0.22;
    let lastAngle = Math.random() * Math.PI * 2;

    for (let i = 0; i < numSittingStones; i++) {
        const angleOffset = (Math.PI * 2 / numSittingStones) * (0.8 + Math.random() * 0.4);
        const angle = lastAngle + angleOffset;
        lastAngle = angle;

        const currentRadius = sittingStoneMinRadius + Math.random() * (sittingStoneMaxRadius - sittingStoneMinRadius);

        const sitStoneSize = 0.08 + Math.random() * 0.07;
        const sitStoneGeo = new THREE.DodecahedronGeometry(sitStoneSize / 1.5, 0);
        const sitStone = new THREE.Mesh(sitStoneGeo, stoneMaterial);
        sitStone.position.set(
            Math.cos(angle) * currentRadius,
            tileY + sitStoneSize / 2,
            Math.sin(angle) * currentRadius
        );
        sitStone.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
        sitStone.castShadow = true;
        sitStone.receiveShadow = true;
        campfireGroup.add(sitStone);
    }

    const flameGroup = new THREE.Group();
    flameGroup.position.y = groundY + logRadius * 2.5;
    campfireGroup.add(flameGroup);

    const flameMaterialOuter = getCachedMaterial(FLAME_COLOR_ORANGE, { transparent: true, opacity: 0.6, side: THREE.DoubleSide, emissive: FLAME_COLOR_ORANGE, emissiveIntensity: 0.5, depthWrite: false }, true);
    const flameMaterialInner = getCachedMaterial(FLAME_COLOR_YELLOW, { transparent: true, opacity: 0.8, side: THREE.DoubleSide, emissive: FLAME_COLOR_YELLOW, emissiveIntensity: 0.8, depthWrite: false }, true);

    const createFlamePlane = (material, size, yOffset) => {
        const planeGeo = new THREE.PlaneGeometry(size, size * 1.8);
        const plane = new THREE.Mesh(planeGeo, material);
        plane.position.y = yOffset + (size * 1.8) / 2;
        return plane;
    };

    const flame1Outer = createFlamePlane(flameMaterialOuter, 0.08, 0);
    const flame1Inner = createFlamePlane(flameMaterialInner, 0.05, 0.01);
    flame1Outer.add(flame1Inner);
    flameGroup.add(flame1Outer);

    const flame2Outer = createFlamePlane(flameMaterialOuter, 0.07, 0.02);
    flame2Outer.rotation.y = Math.PI / 2;
    const flame2Inner = createFlamePlane(flameMaterialInner, 0.04, 0.03);
    flame2Outer.add(flame2Inner);
    flameGroup.add(flame2Outer);

    campfireGroup.userData.flames = [flame1Outer, flame2Outer];

    const fireLight = new THREE.PointLight(FLAME_COLOR_ORANGE, 1.5, 3.5, 1.8);
    fireLight.position.copy(flameGroup.position);
    fireLight.position.y += 0.1;
    fireLight.castShadow = true;
    fireLight.shadow.mapSize.width = 256;
    fireLight.shadow.mapSize.height = 256;
    fireLight.shadow.camera.near = 0.1;
    fireLight.shadow.camera.far = 3;
    campfireGroup.add(fireLight);
    campfireGroup.userData.light = fireLight;
    campfireGroup.userData.isLit = () => fireLight.intensity > 0.3 && fireLight.visible;

    campfireGroup.userData.animate = (time, timeOfDay) => {
        const flames = campfireGroup.userData.flames;
        if (flames) {
            flames.forEach((flame, index) => {
                const scaleFactor = 0.9 + Math.sin(time * (5 + index) + index * 0.5) * 0.15;
                flame.scale.set(scaleFactor, scaleFactor, scaleFactor);
                flame.material.opacity = 0.5 + Math.sin(time * (6 + index) + index * 0.7) * 0.2;
                if (flame.children.length > 0 && flame.children[0].material) {
                    flame.children[0].material.opacity = 0.7 + Math.sin(time * (7 + index) + index * 0.9) * 0.25;
                }
            });
        }
        const light = campfireGroup.userData.light;
        if (light) {
            if (timeOfDay > 18 || timeOfDay < 6) {
                light.intensity = THREE.MathUtils.lerp(light.intensity, 2.0 + Math.sin(time * 3) * 0.3, 0.1);
            } else if (timeOfDay > 6 && timeOfDay < 8) {
                light.intensity = THREE.MathUtils.lerp(light.intensity, 1.0 + Math.sin(time * 3) * 0.2, 0.1);
            }
            else {
                light.intensity = THREE.MathUtils.lerp(light.intensity, 0.5 + Math.sin(time * 3) * 0.1, 0.1);
            }
            light.visible = light.intensity > 0.1;
        }
    };

    return campfireGroup;
};

// --- Farm ---
const FARM_SOIL_COLOR = 0x654321;
const FARM_FENCE_COLOR = 0x8B7355;

const createFarmModel = (tileY) => {
    const farmGroup = new THREE.Group();
    farmGroup.userData.isBuilding = true;
    farmGroup.userData.buildingType = BUILDING_TYPES.FARM;
    farmGroup.userData.animate = (time) => { };

    const soilSize = 0.65;
    const soilHeight = 0.04;
    const soilMaterial = getCachedMaterial(FARM_SOIL_COLOR, { roughness: 0.9 });
    soilMaterial.userData = { isRoof: true };
    const soilGeo = new THREE.BoxGeometry(soilSize, soilHeight, soilSize);
    const soilMesh = new THREE.Mesh(soilGeo, soilMaterial);
    soilMesh.position.y = tileY + soilHeight / 2;
    soilMesh.castShadow = false;
    soilMesh.receiveShadow = true;
    farmGroup.add(soilMesh);

    const fencePostHeight = 0.12;
    const fencePostRadius = 0.012;
    const fenceMaterial = getCachedMaterial(FARM_FENCE_COLOR, { roughness: 0.85 });
    fenceMaterial.userData = { isRoof: true };
    const postGeo = new THREE.CylinderGeometry(fencePostRadius, fencePostRadius, fencePostHeight, 4);

    const s = soilSize / 2;
    const fenceCoords = [
        [-s, -s], [0, -s], [s, -s], [-s, 0], [s, 0], [-s, s], [0, s], [s, s]
    ];

    fenceCoords.forEach(coord => {
        const post = new THREE.Mesh(postGeo, fenceMaterial);
        post.position.set(coord[0], tileY + soilHeight + fencePostHeight / 2 - soilHeight / 2, coord[1]);
        post.castShadow = true;
        farmGroup.add(post);
    });

    return farmGroup;
};


export const createBuildingModel = (buildingType, tileY) => {
    let model;
    switch (buildingType) {
        case BUILDING_TYPES.HOUSE:
            model = createHouseModel(tileY);
            break;
        case BUILDING_TYPES.CAMPFIRE:
            model = createCampfireModel(tileY);
            break;
        case BUILDING_TYPES.FARM:
            model = createFarmModel(tileY);
            break;
        case BUILDING_TYPES.MINE:
        case BUILDING_TYPES.HARBOUR:
        default:
            console.warn(`Building type ${buildingType} model not implemented yet. Using placeholder.`);
            const placeholderGeo = new THREE.BoxGeometry(0.4, 0.4, 0.4);
            const placeholderMat = getCachedMaterial(0x8888FF, { roughness: 0.5 });
            placeholderMat.userData = { isRoof: true };
            const placeholder = new THREE.Mesh(placeholderGeo, placeholderMat);
            placeholder.position.y = tileY + 0.2;
            placeholder.castShadow = true;
            const group = new THREE.Group();
            group.add(placeholder);
            group.userData.isBuilding = true;
            group.userData.buildingType = 'PLACEHOLDER';
            group.userData.animate = (time) => { };
            model = group;
            break;
    }
    if (model) {
        model.rotation.y = Math.random() * Math.PI * 2;
    }
    return model;
};

export const updateBuildingMaterialsForSnow = (buildingInstance, snowAccumulationRatio) => {
    if (!buildingInstance || !buildingInstance.userData?.isBuilding) return;

    const snowColor = new THREE.Color(SNOW_COVER_COLOR);
    const isCampfire = buildingInstance.userData.buildingType === BUILDING_TYPES.CAMPFIRE;
    const isHouse = buildingInstance.userData.buildingType === BUILDING_TYPES.HOUSE;
    const lightIsOn = isCampfire && typeof buildingInstance.userData.isLit === 'function' && buildingInstance.userData.isLit();

    let houseLampIsOn = false;
    if (isHouse && buildingInstance.userData.doorLampLight) {
        houseLampIsOn = buildingInstance.userData.doorLampLight.intensity > 0.05;
    }


    buildingInstance.traverse((node) => {
        if (node.isMesh && node.material) {
            const materials = Array.isArray(node.material) ? node.material : [node.material];
            materials.forEach(material => {
                // Skip emissive materials that control their own appearance (flames, window glass, lamp shade)
                if (material.emissive &&
                    (material.emissive.equals(new THREE.Color(FLAME_COLOR_ORANGE)) ||
                        material.emissive.equals(new THREE.Color(FLAME_COLOR_YELLOW)) ||
                        material.emissive.equals(new THREE.Color(HOUSE_WINDOW_EMISSIVE_COLOR)) ||
                        (material.userData?.isLampShade && material.emissive.equals(new THREE.Color(HOUSE_LAMP_EMISSIVE_COLOR)))
                    )
                ) {
                    return;
                }

                const cacheEntry = buildingMaterialsCache.get(material);
                if (cacheEntry) {
                    let currentLerp = 0;
                    let effectiveSnowRatio = snowAccumulationRatio;

                    if (isCampfire && lightIsOn) {
                        effectiveSnowRatio *= 0.05;
                    }
                    // If it's a lamp post and the lamp is on, reduce snow slightly
                    if (node.parent === buildingInstance.userData.doorLampLight?.parent && houseLampIsOn) { // Check if node is part of lamp group
                        effectiveSnowRatio *= 0.3; // Lamp post gets less snow if lamp is on
                    }


                    if (material.userData && material.userData.isRoof) {
                        currentLerp = effectiveSnowRatio * MAX_SNOW_COVER_LERP_FACTOR;
                    } else {
                        currentLerp = effectiveSnowRatio * MAX_SNOW_COVER_LERP_FACTOR * 0.25;
                    }
                    material.color.copy(cacheEntry.originalColor).lerp(snowColor, Math.min(currentLerp, 1.0));
                    material.needsUpdate = true;
                }
            });
        }
    });
};

export const disposeBuildingMaterials = () => {
    buildingMaterialsCache.forEach((value, material) => {
        material.dispose();
    });
    buildingMaterialsCache.clear();
};

## src\components\HexMap\utils\colorUtils.js ##
// src/components/HexMap/utils/colorUtils.js
import * as THREE from 'three';
import { MOON_COLOR, WEATHER_TYPES, SEASONS } from '../constants';

export const calculateSunPosition = (timeOfDay, season, maxSummerEle, maxWinterEle, azimuthSwing) => {
    let currentMaxElevation;
    if (season === SEASONS.SUMMER) currentMaxElevation = maxSummerEle;
    else if (season === SEASONS.WINTER) currentMaxElevation = maxWinterEle;
    else if (season === SEASONS.SPRING) currentMaxElevation = (maxSummerEle + maxWinterEle) / 2 + 5;
    else currentMaxElevation = (maxSummerEle + maxWinterEle) / 2 - 5;

    const normalizedTime = timeOfDay / 24;
    let elevation = Math.sin(normalizedTime * Math.PI * 2 - Math.PI / 2) * (currentMaxElevation + 10) - 10;
    elevation = Math.max(-90, Math.min(90, elevation));

    let azimuth = 0;
    if (elevation > -5) {
        azimuth = 180 - Math.cos(normalizedTime * Math.PI * 2) * azimuthSwing;
    } else {
        azimuth = (180 - Math.cos(normalizedTime * Math.PI * 2) * azimuthSwing + 180) % 360;
    }
    azimuth = (azimuth + 360) % 360;

    return { elevation, azimuth };
};

export const getSunLightColor = (sunElevation) => {
    const effectiveElevation = Math.max(0, sunElevation);
    const elevationNormalized = Math.min(effectiveElevation, 90) / 90;
    const middayColor = new THREE.Color(0xFFFDD0);
    const horizonSetColor = new THREE.Color(0xFF8C00);
    const horizonRiseColor = new THREE.Color(0xFF4500);
    const twilightColor = new THREE.Color(0x4682B4);

    if (sunElevation < -5) {
        return new THREE.Color(0x050510);
    } else if (sunElevation < 0) {
        return horizonRiseColor.clone().lerp(twilightColor, (sunElevation + 5) / 5);
    } else if (elevationNormalized < 0.05) {
        return horizonRiseColor.clone().lerp(horizonSetColor, elevationNormalized / 0.05);
    } else if (elevationNormalized < 0.20) {
        return horizonSetColor.clone().lerp(middayColor, (elevationNormalized - 0.05) / (0.20 - 0.05));
    }
    return middayColor.clone();
};

export const getMoonLightColor = (moonElevation) => {
    if (moonElevation < -5) {
        return new THREE.Color(0x000000);
    }
    const intensityFactor = Math.min(1, Math.max(0, (moonElevation + 5) / 40));
    return new THREE.Color(MOON_COLOR).multiplyScalar(intensityFactor);
};

// Added snowAccumulationRatio parameter
export const getSkyAndFogColor = (sunElevation, moonElevation, sunLightColor, weatherCondition, season, snowAccumulationRatio = 0) => {
    const skyColorResult = new THREE.Color();

    const dayZenithBase = new THREE.Color(0x87CEEB);
    const dayHorizonBase = new THREE.Color(0xADD8E6);
    const nightZenithBase = new THREE.Color(0x0A0A1A);
    const nightHorizonBase = new THREE.Color(0x101025);

    const cloudyDayZenith = new THREE.Color(0xB0C4DE);
    const cloudyDayHorizon = new THREE.Color(0x778899);
    const cloudyNightZenith = new THREE.Color(0x2F4F4F);
    const cloudyNightHorizon = new THREE.Color(0x1E2D2D);

    // Define specific snowy sky colors (target for when snowAccumulationRatio is 1)
    const snowyDayZenith = new THREE.Color(0xDDEEFF);   // Whiter, brighter blue
    const snowyDayHorizon = new THREE.Color(0xC0D0E0);  // Light greyish blue
    const snowyNightZenith = new THREE.Color(0x354045); // Darker, slightly brighter than cloudy night
    const snowyNightHorizon = new THREE.Color(0x283035);

    let currentDayZenith = dayZenithBase.clone();
    let currentDayHorizon = dayHorizonBase.clone();
    let currentNightZenith = nightZenithBase.clone();
    let currentNightHorizon = nightHorizonBase.clone();

    const isActuallySnowing = weatherCondition === WEATHER_TYPES.SNOW && season === SEASONS.WINTER;

    if (weatherCondition === WEATHER_TYPES.CLOUDY || weatherCondition === WEATHER_TYPES.RAINY) {
        currentDayZenith.copy(cloudyDayZenith);
        currentDayHorizon.copy(cloudyDayHorizon);
        currentNightZenith.copy(cloudyNightZenith);
        currentNightHorizon.copy(cloudyNightHorizon);
    }

    // If it's actually snowing, interpolate current sky colors towards the snowy sky colors
    if (isActuallySnowing) {
        currentDayZenith.lerp(snowyDayZenith, snowAccumulationRatio);
        currentDayHorizon.lerp(snowyDayHorizon, snowAccumulationRatio);
        currentNightZenith.lerp(snowyNightZenith, snowAccumulationRatio);
        currentNightHorizon.lerp(snowyNightHorizon, snowAccumulationRatio);
    } else if (snowAccumulationRatio > 0) { // If snow is melting
        // Interpolate from the fully snowy sky back to the current weather's base sky
        const baseDZ = (weatherCondition === WEATHER_TYPES.CLOUDY || weatherCondition === WEATHER_TYPES.RAINY) ? cloudyDayZenith : dayZenithBase;
        const baseDH = (weatherCondition === WEATHER_TYPES.CLOUDY || weatherCondition === WEATHER_TYPES.RAINY) ? cloudyDayHorizon : dayHorizonBase;
        const baseNZ = (weatherCondition === WEATHER_TYPES.CLOUDY || weatherCondition === WEATHER_TYPES.RAINY) ? cloudyNightZenith : nightZenithBase;
        const baseNH = (weatherCondition === WEATHER_TYPES.CLOUDY || weatherCondition === WEATHER_TYPES.RAINY) ? cloudyNightHorizon : nightHorizonBase;

        currentDayZenith.copy(snowyDayZenith).lerp(baseDZ, 1.0 - snowAccumulationRatio);
        currentDayHorizon.copy(snowyDayHorizon).lerp(baseDH, 1.0 - snowAccumulationRatio);
        currentNightZenith.copy(snowyNightZenith).lerp(baseNZ, 1.0 - snowAccumulationRatio);
        currentNightHorizon.copy(snowyNightHorizon).lerp(baseNH, 1.0 - snowAccumulationRatio);
    }


    const sunInfluenceNormalized = Math.max(0, Math.min(sunElevation, 90)) / 90;
    const moonInfluenceNormalized = Math.max(0, Math.min(moonElevation, 90)) / 90;

    const finalDaySky = new THREE.Color().copy(currentDayHorizon).lerp(currentDayZenith, sunInfluenceNormalized * 0.8);
    if (sunElevation > -5 && sunElevation < 20 && weatherCondition === WEATHER_TYPES.CLEAR && !isActuallySnowing) {
        const sunsetFactor = 1.0 - Math.min(1, Math.max(0, (sunElevation + 5)) / 25);
        finalDaySky.lerp(sunLightColor, sunsetFactor * 0.4);
    }

    const finalNightSky = new THREE.Color().copy(currentNightHorizon).lerp(currentNightZenith, 0.5 + moonInfluenceNormalized * 0.5);
    if (moonElevation > 0 && weatherCondition === WEATHER_TYPES.CLEAR && !isActuallySnowing) {
        finalNightSky.lerp(new THREE.Color(MOON_COLOR), moonInfluenceNormalized * 0.15);
    }

    if (sunElevation > 15) {
        skyColorResult.copy(finalDaySky);
    } else if (sunElevation < -8) {
        skyColorResult.copy(finalNightSky);
    } else {
        const twilightFactor = (sunElevation + 8) / (15 + 8);
        skyColorResult.copy(finalNightSky).lerp(finalDaySky, twilightFactor);
    }

    if (weatherCondition === WEATHER_TYPES.RAINY && !isActuallySnowing) { // Don't apply if transitioning to snow
        skyColorResult.lerp(new THREE.Color(0x333338), 0.5);
        skyColorResult.multiplyScalar(0.7);
    }
    // General overcast/snow darkening is handled by the sky color lerping now.
    // If specifically snowing (target state), slight additional modification if needed.
    if (isActuallySnowing) {
        skyColorResult.lerp(new THREE.Color(0xCFD8DC), snowAccumulationRatio * 0.15); // Subtle brightening/desaturation as snow fully sets in
        skyColorResult.multiplyScalar(THREE.MathUtils.lerp(1.0, 0.9, snowAccumulationRatio));
    }


    return skyColorResult;
};

## src\components\HexMap\utils\foxUtils.js ##
// src/components/HexMap/utils/foxUtils.js
import * as THREE from 'three';

const FOX_BODY_COLOR = 0xD2691E;
const FOX_SNOUT_COLOR = 0xFFE4C4;
const FOX_LEG_COLOR = 0x4A2A2A;

export const FOX_SPEED = 0.75;
export const FOX_TURN_SPEED = Math.PI * 2;

export const FOX_MAX_LEG_SWING_X = Math.PI / 5;
export const FOX_LEG_ANIM_SPEED_FACTOR = 10;
export const FOX_HEAD_BOB_AMOUNT = 0.015;
export const FOX_HEAD_BOB_SPEED_FACTOR = FOX_LEG_ANIM_SPEED_FACTOR * 1.5;
export const FOX_TAIL_WAG_ANGLE_Z = Math.PI / 18;
export const FOX_TAIL_WAG_SPEED_FACTOR = FOX_LEG_ANIM_SPEED_FACTOR * 0.9;

export const FOX_HEAD_IDLE_TURN_Y_ANGLE = Math.PI / 8;
export const FOX_HEAD_IDLE_SPEED_FACTOR = 0.4;
export const FOX_TAIL_IDLE_SWISH_Z_ANGLE = Math.PI / 24;
export const FOX_TAIL_IDLE_SPEED_FACTOR = 0.6;

const bodyMaterial = new THREE.MeshStandardMaterial({ color: FOX_BODY_COLOR, roughness: 0.7, metalness: 0.1 });
const snoutMaterial = new THREE.MeshStandardMaterial({ color: FOX_SNOUT_COLOR, roughness: 0.7, metalness: 0.1 });
const legMaterial = new THREE.MeshStandardMaterial({ color: FOX_LEG_COLOR, roughness: 0.7, metalness: 0.1 });

export const createFoxModel = () => {
    const foxGroup = new THREE.Group();
    foxGroup.userData = {};

    const bodyGeo = new THREE.BoxGeometry(0.5, 0.2, 0.25);
    const bodyMesh = new THREE.Mesh(bodyGeo, bodyMaterial);
    bodyMesh.position.y = 0.12;
    foxGroup.add(bodyMesh);
    foxGroup.userData.body = bodyMesh;

    const headMesh = new THREE.Group();
    headMesh.position.set(0.25, 0.22, 0);
    foxGroup.add(headMesh);
    foxGroup.userData.head = headMesh;
    foxGroup.userData.headOriginalY = headMesh.position.y;

    const headGeo = new THREE.BoxGeometry(0.18, 0.18, 0.18);
    const actualHeadMesh = new THREE.Mesh(headGeo, bodyMaterial);
    headMesh.add(actualHeadMesh);

    const snoutGeo = new THREE.ConeGeometry(0.05, 0.15, 4);
    const snoutMesh = new THREE.Mesh(snoutGeo, snoutMaterial);
    snoutMesh.position.set(0.09, 0, 0);
    snoutMesh.rotation.z = -Math.PI / 2;
    headMesh.add(snoutMesh);

    const earGeo = new THREE.ConeGeometry(0.04, 0.1, 3);
    const leftEar = new THREE.Mesh(earGeo, legMaterial);
    leftEar.position.set(-0.02, 0.1, 0.05);
    headMesh.add(leftEar);
    const rightEar = new THREE.Mesh(earGeo, legMaterial);
    rightEar.position.set(-0.02, 0.1, -0.05);
    headMesh.add(rightEar);

    const legHeight = 0.15;
    const legGeo = new THREE.CylinderGeometry(0.03, 0.02, legHeight, 4);
    const legPositions = [
        { x: 0.18, y: 0.02, z: 0.09, name: 'frontLeft' },
        { x: 0.18, y: 0.02, z: -0.09, name: 'frontRight' },
        { x: -0.18, y: 0.02, z: 0.09, name: 'backLeft' },
        { x: -0.18, y: 0.02, z: -0.09, name: 'backRight' }
    ];

    foxGroup.userData.legs = {};
    legPositions.forEach(posData => {
        const legPivot = new THREE.Group();
        legPivot.position.set(posData.x, posData.y, posData.z);
        foxGroup.add(legPivot);

        const legMesh = new THREE.Mesh(legGeo, legMaterial);
        legMesh.position.y = -legHeight / 2;
        legPivot.add(legMesh);

        foxGroup.userData.legs[posData.name] = legPivot;
    });

    const tailMesh = new THREE.Group();
    tailMesh.position.set(-0.3, 0.10, 0);
    tailMesh.rotation.z = -Math.PI / 6;
    foxGroup.add(tailMesh);
    foxGroup.userData.tail = tailMesh;
    foxGroup.userData.tailOriginalZRotation = tailMesh.rotation.z;

    const tailGeo = new THREE.CylinderGeometry(0.03, 0.06, 0.25, 5);
    const actualTailMesh = new THREE.Mesh(tailGeo, bodyMaterial);
    tailMesh.add(actualTailMesh);

    const tailTipGeo = new THREE.SphereGeometry(0.065);
    const tailTip = new THREE.Mesh(tailTipGeo, snoutMaterial);
    actualTailMesh.add(tailTip);
    tailTip.position.y = -0.125;


    foxGroup.castShadow = true;
    foxGroup.traverse(child => {
        if (child.isMesh) child.castShadow = true;
    });

    return foxGroup;
};

export const disposeFoxMaterials = () => {
    bodyMaterial.dispose();
    snoutMaterial.dispose();
    legMaterial.dispose();
};

## src\components\HexMap\utils\mapGenerator.js ##
// src/components/HexMap/utils/mapGenerator.js
import {
    TILE_TYPES, BIOME_THRESHOLDS,
    WATER_SURFACE_ELEVATION_NORMALIZED,
    SHALLOW_WATER_DEPTH_FOR_REEDS_NORMALIZED,
    MAP_GENERATOR_DEFAULTS
} from '../constants';

const randomFloat = (min, max) => Math.random() * (max - min) + min;

const isNearLandEdge = (finalNormalizedElevation) =>
    finalNormalizedElevation < BIOME_THRESHOLDS[TILE_TYPES.SAND];

export const generateCoolIslandMap = (
    columns,
    rows,
    numIslands = MAP_GENERATOR_DEFAULTS.NUM_ISLANDS,
    islandSizeFactor = MAP_GENERATOR_DEFAULTS.ISLAND_SIZE_FACTOR,
    noiseStrength = MAP_GENERATOR_DEFAULTS.NOISE_STRENGTH,
    warpFactor = MAP_GENERATOR_DEFAULTS.WARP_FACTOR,
    islandBorderFactor = MAP_GENERATOR_DEFAULTS.ISLAND_BORDER_FACTOR,
    randomnessFactor = MAP_GENERATOR_DEFAULTS.RANDOMNESS_FACTOR
) => {
    const mapData = new Map();

    const islandSeeds = [];
    for (let i = 0; i < numIslands; i++) {
        islandSeeds.push({
            x: Math.random() * columns,
            y: Math.random() * rows,
            strength: 0.7 + Math.random() * 0.6
        });
    }

    const maxDistForSeedInfluence = Math.sqrt(columns * columns + rows * rows) * islandSizeFactor;
    const mapCenterX = (columns - 1) / 2.0;
    const mapCenterY = (rows - 1) / 2.0;
    const effectiveIslandRadiusX = mapCenterX * islandBorderFactor;
    const effectiveIslandRadiusY = mapCenterY * islandBorderFactor;

    for (let r_iter = 0; r_iter < rows; r_iter++) {
        for (let c_iter = 0; c_iter < columns; c_iter++) {
            const c = c_iter;
            const r = r_iter;

            const warpX = (Math.sin(c * 0.15 + r * 0.25) + Math.cos(c * 0.08 - r * 0.18)) * columns * warpFactor;
            const warpY = (Math.sin(r * 0.15 - c * 0.22) + Math.cos(r * 0.07 + c * 0.15)) * rows * warpFactor;
            const wc = c + warpX;
            const wr = r + warpY;

            let baseElevation = 0;
            for (const seed of islandSeeds) {
                const dx_seed = wc - seed.x;
                const dy_seed = wr - seed.y;
                const dist_seed = Math.sqrt(dx_seed * dx_seed + dy_seed * dy_seed);
                const influence = seed.strength * Math.exp(- (dist_seed * dist_seed) / (maxDistForSeedInfluence * maxDistForSeedInfluence * 0.5));
                baseElevation += influence;
            }
            baseElevation = Math.min(baseElevation, 1.0);

            let noiseValue = 0;
            noiseValue += 0.5 * (Math.sin(wc * 0.05 + wr * 0.07) + Math.cos(wc * 0.03 - wr * 0.06));
            noiseValue += 0.25 * (Math.sin(wc * 0.12 + wr * 0.15) + Math.cos(wc * 0.08 - wr * 0.11));
            noiseValue += 0.125 * (Math.sin(wc * 0.25 + wr * 0.3) + Math.cos(wc * 0.18 - wr * 0.22));
            noiseValue = (noiseValue / (0.5 + 0.25 + 0.125)) * 0.5 + 0.5;

            let combinedElevation = baseElevation * (0.6 + noiseValue * 0.4 * noiseStrength);
            combinedElevation += 0.05 * Math.sin(c * 0.02 + r * 0.015);

            if (baseElevation > 0.2) {
                combinedElevation = Math.max(combinedElevation, 0.01);
            }

            const dx_mapCenter = c - mapCenterX;
            const dy_mapCenter = r - mapCenterY;
            const normDistX = effectiveIslandRadiusX > 0 ? (dx_mapCenter / effectiveIslandRadiusX) : 0;
            const normDistY = effectiveIslandRadiusY > 0 ? (dy_mapCenter / effectiveIslandRadiusY) : 0;
            const radialDist = Math.sqrt(normDistX * normDistX + normDistY * normDistY);

            let islandShapeMultiplier = 0.0;
            if (radialDist < 1.0) {
                islandShapeMultiplier = (Math.cos(radialDist * Math.PI) + 1.0) / 2.0;
                islandShapeMultiplier = Math.pow(islandShapeMultiplier, 1.5);
            }

            let finalNormalizedElevation = combinedElevation * islandShapeMultiplier;
            finalNormalizedElevation = Math.min(Math.max(finalNormalizedElevation, 0.0), 1.0);

            let tileType;
            const randomInfluence = randomFloat(-randomnessFactor, randomnessFactor);
            const biomeCheckElevation = finalNormalizedElevation + randomInfluence;

            const lowerShallowWaterLimit = WATER_SURFACE_ELEVATION_NORMALIZED - SHALLOW_WATER_DEPTH_FOR_REEDS_NORMALIZED;

            if (finalNormalizedElevation < lowerShallowWaterLimit) {
                tileType = TILE_TYPES.DEEP_WATER;
            } else if (finalNormalizedElevation < WATER_SURFACE_ELEVATION_NORMALIZED) {
                tileType = TILE_TYPES.SHALLOW_WATER;
            } else {
                if (biomeCheckElevation < BIOME_THRESHOLDS[TILE_TYPES.SAND]) {
                    tileType = TILE_TYPES.SAND;
                } else if (biomeCheckElevation < BIOME_THRESHOLDS[TILE_TYPES.CLAY]) {
                    if (finalNormalizedElevation < BIOME_THRESHOLDS[TILE_TYPES.SAND] * 1.05 && Math.random() < 0.4) {
                        tileType = TILE_TYPES.SAND;
                    } else {
                        tileType = TILE_TYPES.CLAY;
                    }
                } else if (biomeCheckElevation < BIOME_THRESHOLDS[TILE_TYPES.PASTURE]) {
                    if (isNearLandEdge(finalNormalizedElevation) && Math.random() < 0.25) {
                        tileType = TILE_TYPES.CLAY;
                    } else {
                        tileType = TILE_TYPES.PASTURE;
                    }
                } else if (biomeCheckElevation < BIOME_THRESHOLDS[TILE_TYPES.FOREST]) {
                    if (isNearLandEdge(finalNormalizedElevation) && finalNormalizedElevation < BIOME_THRESHOLDS[TILE_TYPES.CLAY] && Math.random() < 0.7) {
                        tileType = TILE_TYPES.PASTURE;
                    } else if (islandShapeMultiplier < 0.7 && baseElevation < 0.55 && Math.random() < 0.4) {
                        tileType = TILE_TYPES.PASTURE;
                    } else {
                        tileType = TILE_TYPES.FOREST;
                    }
                } else if (biomeCheckElevation < BIOME_THRESHOLDS[TILE_TYPES.STONE]) {
                    if (biomeCheckElevation < BIOME_THRESHOLDS[TILE_TYPES.FOREST] * 1.08 && Math.random() < 0.3) {
                        tileType = TILE_TYPES.FOREST;
                    } else {
                        tileType = TILE_TYPES.STONE;
                    }
                } else {
                    tileType = TILE_TYPES.MOUNTAIN_PEAK;
                }
            }

            mapData.set(`${c},${r}`, {
                normalizedElevation: finalNormalizedElevation,
                type: tileType
            });
        }
    }
    console.log("Generated island map data:", mapData.size > 0 ? `${mapData.size} tiles` : "Empty");
    return mapData;
};

## src\components\HexMap\utils\reedsUtils.js ##
// src/components/HexMap/utils/reedsUtils.js
import * as THREE from 'three';
import { SNOW_COVER_COLOR, MAX_SNOW_COVER_LERP_FACTOR } from '../constants';

const REED_STALK_HEIGHT_MIN = 0.5;
const REED_STALK_HEIGHT_MAX = 1.2;
const REED_STALK_RADIUS = 0.015;
const REED_STALKS_PER_CLUMP_MIN = 3;
const REED_STALKS_PER_CLUMP_MAX = 7;
const REED_CLUMP_SPREAD_RADIUS = 0.15;
const REED_COLOR_HEX = 0x8FBC8F;

const reedMaterial = new THREE.MeshStandardMaterial({
    color: REED_COLOR_HEX,
    roughness: 0.7,
    metalness: 0.0,
    flatShading: false,
    side: THREE.DoubleSide,
});
const originalReedColor = reedMaterial.color.clone();

export const createReedClump = () => {
    const clump = new THREE.Group();
    const numStalks = Math.floor(Math.random() * (REED_STALKS_PER_CLUMP_MAX - REED_STALKS_PER_CLUMP_MIN + 1)) + REED_STALKS_PER_CLUMP_MIN;

    for (let i = 0; i < numStalks; i++) {
        const stalkHeight = Math.random() * (REED_STALK_HEIGHT_MAX - REED_STALK_HEIGHT_MIN) + REED_STALK_HEIGHT_MIN;
        const stalkGeometry = new THREE.CylinderGeometry(REED_STALK_RADIUS, REED_STALK_RADIUS, stalkHeight, 5);
        const stalkMesh = new THREE.Mesh(stalkGeometry, reedMaterial);
        stalkMesh.castShadow = true;
        const angle = Math.random() * Math.PI * 2;
        const radius = Math.random() * REED_CLUMP_SPREAD_RADIUS;
        const xOffset = Math.cos(angle) * radius;
        const zOffset = Math.sin(angle) * radius;
        stalkMesh.position.set(xOffset, stalkHeight / 2, zOffset);
        stalkMesh.rotation.x = (Math.random() - 0.5) * 0.15;
        stalkMesh.rotation.z = (Math.random() - 0.5) * 0.15;
        clump.add(stalkMesh);
    }
    return clump;
};

// snowAccumulationRatio is 0 (no snow) to 1 (full snow)
export const updateReedMaterialsForSnow = (snowAccumulationRatio) => {
    const snowColor = new THREE.Color(SNOW_COVER_COLOR);
    // Reeds get more heavily 'snowed' or appear frosted
    const currentLerp = snowAccumulationRatio * MAX_SNOW_COVER_LERP_FACTOR * 1.15; // Slightly more effect
    reedMaterial.color.copy(originalReedColor).lerp(snowColor, Math.min(currentLerp, 1.0)); // Cap lerp at 1
    reedMaterial.needsUpdate = true;
};

export const disposeReedMaterial = () => {
    if (reedMaterial) reedMaterial.dispose();
};

## src\components\HexMap\utils\rockUtils.js ##
// src/components/HexMap/utils/rockUtils.js
import * as THREE from 'three';
import { SNOW_COVER_COLOR, MAX_SNOW_COVER_LERP_FACTOR } from '../constants';

const ROCK_SIZE_MIN = 0.25;
const ROCK_SIZE_MAX = 0.7;
const ROCK_DETAIL = 0;

const ROCK_COLORS_HEX = [
    0x808080, 0x778899, 0x696969, 0x8B8682,
];

const originalRockColors = ROCK_COLORS_HEX.map(hex => new THREE.Color(hex));

const rockMaterials = originalRockColors.map(color => new THREE.MeshStandardMaterial({
    color: color.clone(),
    roughness: 0.75,
    metalness: 0.1,
    flatShading: true,
}));

export const createRock = (forcedSize) => {
    const size = forcedSize !== undefined
        ? forcedSize
        : Math.random() * (ROCK_SIZE_MAX - ROCK_SIZE_MIN) + ROCK_SIZE_MIN;

    const geometry = new THREE.DodecahedronGeometry(size / 1.8, ROCK_DETAIL);
    const material = rockMaterials[Math.floor(Math.random() * rockMaterials.length)];
    const rockMesh = new THREE.Mesh(geometry, material);
    rockMesh.castShadow = true;
    rockMesh.receiveShadow = true;
    return rockMesh;
};

// snowAccumulationRatio is 0 (no snow) to 1 (full snow)
export const updateRockMaterialsForSnow = (snowAccumulationRatio) => {
    const snowColor = new THREE.Color(SNOW_COVER_COLOR);
    const currentLerp = snowAccumulationRatio * MAX_SNOW_COVER_LERP_FACTOR;

    rockMaterials.forEach((material, index) => {
        material.color.copy(originalRockColors[index]).lerp(snowColor, currentLerp);
        material.needsUpdate = true;
    });
};

export const disposeRockMaterials = () => {
    rockMaterials.forEach(material => material.dispose());
};

## src\components\HexMap\utils\threeUtils.js ##
// src/components/HexMap/utils/threeUtils.js
import * as THREE from 'three';

export const createHexagonGeometry = (size, height) => {
    return new THREE.CylinderGeometry(size, size, height, 6);
};

export const createHexagonInstance = (geometry, material, x, y, z) => {
    const hexMesh = new THREE.Mesh(geometry, material);
    hexMesh.position.set(x, y, z);
    hexMesh.castShadow = true;
    hexMesh.receiveShadow = true;
    return hexMesh;
};

## src\components\HexMap\utils\treeUtils.js ##
// src/components/HexMap/utils/treeUtils.js
import * as THREE from 'three';
import { SNOW_COVER_COLOR, MAX_SNOW_COVER_LERP_FACTOR } from '../constants';


// --- Cypress Tree Constants ---
const CYPRESS_BASE_RADIUS_MIN = 0.2;
const CYPRESS_BASE_RADIUS_MAX = 0.3;
const CYPRESS_HEIGHT_BASE_MIN = 1.2;
const CYPRESS_HEIGHT_BASE_MAX = 2.5;
const CYPRESS_RADIAL_SEGMENTS = 5;
const CYPRESS_FOLIAGE_COLOR_HEX = 0x808060;

// --- Trunk Constants ---
const TRUNK_HEIGHT_BASE_MIN = 0.3;
const TRUNK_HEIGHT_BASE_MAX = 0.6;
const TRUNK_RADIUS_FACTOR = 0.45;
const TRUNK_COLOR_HEX = 0x5D4037;
const TRUNK_RADIAL_SEGMENTS = 4;
const TRUNK_SNOW_COVER_MULTIPLIER = 0.15; // Reduced snow effect on trunks

const ELEVATION_INFLUENCE_ON_TREE_HEIGHT = 0.6;

const foliageMaterial = new THREE.MeshStandardMaterial({
    color: CYPRESS_FOLIAGE_COLOR_HEX,
    roughness: 0.8,
    metalness: 0.1,
    flatShading: true,
});
const originalFoliageColor = foliageMaterial.color.clone();

const trunkMaterial = new THREE.MeshStandardMaterial({
    color: TRUNK_COLOR_HEX,
    roughness: 0.85,
    metalness: 0.05,
    flatShading: true,
});
const originalTrunkColor = trunkMaterial.color.clone();


export const createCypressTree = (
    forcedFoliageHeight,
    forcedFoliageBaseRadius,
    hexNormalizedElevationFactor = 0.5
) => {
    const minHeightMultiplier = 0.7 + (ELEVATION_INFLUENCE_ON_TREE_HEIGHT * hexNormalizedElevationFactor * 0.6);
    const maxHeightMultiplier = 0.8 + (ELEVATION_INFLUENCE_ON_TREE_HEIGHT * hexNormalizedElevationFactor * 0.5);

    const currentFoliageHeightMin = CYPRESS_HEIGHT_BASE_MIN * minHeightMultiplier;
    const currentFoliageHeightMax = CYPRESS_HEIGHT_BASE_MAX * maxHeightMultiplier;

    const currentTrunkHeightMin = TRUNK_HEIGHT_BASE_MIN * minHeightMultiplier;
    const currentTrunkHeightMax = TRUNK_HEIGHT_BASE_MAX * maxHeightMultiplier;

    const foliageHeight = forcedFoliageHeight !== undefined
        ? forcedFoliageHeight
        : Math.max(0.5, Math.random() * (currentFoliageHeightMax - currentFoliageHeightMin) + currentFoliageHeightMin);

    const foliageBaseRadius = forcedFoliageBaseRadius !== undefined
        ? forcedFoliageBaseRadius
        : Math.random() * (CYPRESS_BASE_RADIUS_MAX - CYPRESS_BASE_RADIUS_MIN) + CYPRESS_BASE_RADIUS_MIN;

    const trunkHeight = Math.max(0.15, Math.random() * (currentTrunkHeightMax - currentTrunkHeightMin) + currentTrunkHeightMin);
    const trunkRadius = foliageBaseRadius * TRUNK_RADIUS_FACTOR;
    const minVisibleTrunkRadius = 0.04;
    const finalTrunkRadius = Math.max(minVisibleTrunkRadius, trunkRadius);

    const foliageGeometry = new THREE.ConeGeometry(
        foliageBaseRadius, foliageHeight, CYPRESS_RADIAL_SEGMENTS, 1, false
    );
    const foliageMesh = new THREE.Mesh(foliageGeometry, foliageMaterial);
    foliageMesh.castShadow = true;

    const trunkGeometry = new THREE.CylinderGeometry(
        finalTrunkRadius, finalTrunkRadius, trunkHeight, TRUNK_RADIAL_SEGMENTS
    );
    const trunkMesh = new THREE.Mesh(trunkGeometry, trunkMaterial);
    trunkMesh.castShadow = true;
    trunkMesh.position.y = trunkHeight / 2;

    const tree = new THREE.Group();
    tree.add(trunkMesh);
    foliageMesh.position.y = trunkHeight + foliageHeight / 2;
    tree.add(foliageMesh);

    return tree;
};

export const updateTreeMaterialsForSnow = (snowAccumulationRatio) => {
    const snowColor = new THREE.Color(SNOW_COVER_COLOR);
    const currentFoliageLerp = snowAccumulationRatio * MAX_SNOW_COVER_LERP_FACTOR;
    // Use the new TRUNK_SNOW_COVER_MULTIPLIER
    const currentTrunkLerp = snowAccumulationRatio * MAX_SNOW_COVER_LERP_FACTOR * TRUNK_SNOW_COVER_MULTIPLIER;

    foliageMaterial.color.copy(originalFoliageColor).lerp(snowColor, currentFoliageLerp);
    trunkMaterial.color.copy(originalTrunkColor).lerp(snowColor, currentTrunkLerp);

    foliageMaterial.needsUpdate = true;
    trunkMaterial.needsUpdate = true;
};


export const disposeTreeMaterial = () => {
    if (foliageMaterial) foliageMaterial.dispose();
    if (trunkMaterial) trunkMaterial.dispose();
};
